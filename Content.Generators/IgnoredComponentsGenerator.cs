using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Content.Generators
{
    public class IgnoredComponentsGenerator : ISourceGenerator
    {
        private const string ServerAttName = "Content.AutoGenerated.IgnoreOnServer";
        private const string ClientAttName = "Content.AutoGenerated.IgnoreOnClient";
        private const string AttFile = "GenerateTypedNameReferencesAttribute";
        private const string ServerAttCode = @"// <auto-generated />
using System;
namespace Content.AutoGenerated
{
    [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
    public sealed class IgnoreOnServer : Attribute { }
}
";
        private const string ClientAttCode = @"// <auto-generated />
using System;
namespace Content.AutoGenerated
{
    [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
    public sealed class IgnoreOnClient : Attribute { }
}
";

        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new ComponentSyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            if(!(context.SyntaxReceiver is ComponentSyntaxReceiver receiver)) return;

            var comp = (CSharpCompilation) context.Compilation;

            string attributeName;
            string attributeCode;
            switch (comp.AssemblyName)
            {
                case "Robust.Client":
                    attributeName = ServerAttName;
                    attributeCode = ServerAttCode;
                    break;
                case "Robust.Server":
                    attributeName = ClientAttName;
                    attributeCode = ClientAttCode;
                    break;
                default:
                    context.ReportDiagnostic(
                        Diagnostic.Create(
                            new DiagnosticDescriptor("RIC0000",
                                $"Unknown AssemblyName: {comp.AssemblyName}.",
                                "", "MsBuild", DiagnosticSeverity.Error, true), Location.None));
                    return;
            }
            if (comp.GetTypeByMetadataName(attributeName) == null)
            {
                context.AddSource(AttFile, SourceText.From(attributeCode, Encoding.UTF8));
                comp = comp.AddSyntaxTrees(CSharpSyntaxTree.ParseText(SourceText.From(attributeCode, Encoding.UTF8),
                    (CSharpParseOptions) comp.SyntaxTrees[0].Options));
            }

            var attrSymbol = comp.GetTypeByMetadataName(attributeName);
            var componentNames = new List<string>();
            foreach (var candidateClass in receiver.CandidateClasses)
            {
                var model = comp.GetSemanticModel(candidateClass.SyntaxTree);
                var typeSymbol = (INamedTypeSymbol) model.GetDeclaredSymbol(candidateClass);

                var attributeData = typeSymbol.GetAttributes().FirstOrDefault(a =>
                    a.AttributeClass != null &&
                    a.AttributeClass.Equals(attrSymbol, SymbolEqualityComparer.Default));;

                if (attributeData == null)
                {
                    continue;
                }

                var nameProperty = ((PropertyDeclarationSyntax)candidateClass.Members.FirstOrDefault(p =>
                    p is PropertyDeclarationSyntax propertyDeclarationSyntax &&
                    propertyDeclarationSyntax.Identifier.Text == "Name" &&
                    propertyDeclarationSyntax.Modifiers.Count == 1 &&
                    propertyDeclarationSyntax.Modifiers[0].Text == "public"));

                if (nameProperty == null)
                {
                    context.ReportDiagnostic(
                        Diagnostic.Create(
                            new DiagnosticDescriptor("RIC0001",
                                $"No Name-Property found for marked type {typeSymbol}.",
                                "", "Usage", DiagnosticSeverity.Error, true), typeSymbol.Locations[0]));
                    return;
                }

                string compName;
                if(nameProperty.ExpressionBody != null)
                {
                    if (!(nameProperty.ExpressionBody.Expression is LiteralExpressionSyntax literalExpressionSyntax))
                    {
                        context.ReportDiagnostic(
                            Diagnostic.Create(
                                new DiagnosticDescriptor("RIC0002",
                                    $"Name-Property returns non-literal String for type {typeSymbol}.",
                                    "", "Usage", DiagnosticSeverity.Error, true), nameProperty.GetLocation()));
                        return;
                    }
                    compName = literalExpressionSyntax.Token.Text;
                }else if (nameProperty.AccessorList != null)
                {
                    var getAccessor = nameProperty.AccessorList.Accessors.FirstOrDefault(a => a.Keyword.Text == "get");
                    if (getAccessor == null)
                    {
                        context.ReportDiagnostic(
                            Diagnostic.Create(
                                new DiagnosticDescriptor("RIC0002",
                                    $"No get-accessor found for Name-Property of type {typeSymbol}.",
                                    "", "Usage", DiagnosticSeverity.Error, true), nameProperty.GetLocation()));
                        return;
                    }

                    if (getAccessor.ExpressionBody != null)
                    {
                        if (!(getAccessor.ExpressionBody.Expression is LiteralExpressionSyntax literalExpressionSyntax))
                        {
                            context.ReportDiagnostic(
                                Diagnostic.Create(
                                    new DiagnosticDescriptor("RIC0002",
                                        $"Name-Property returns non-literal String for type {typeSymbol}.",
                                        "", "Usage", DiagnosticSeverity.Error, true), getAccessor.ExpressionBody.Expression.GetLocation()));
                            return;
                        }

                        compName = literalExpressionSyntax.Token.Text;
                    }else if (getAccessor.Body != null)
                    {
                        if (getAccessor.Body.Statements.Count != 1 ||
                            !(getAccessor.Body.Statements[0] is ReturnStatementSyntax returnStatement) ||
                            !(returnStatement.Expression is LiteralExpressionSyntax literalExpressionSyntax))
                        {
                            context.ReportDiagnostic(
                                Diagnostic.Create(
                                    new DiagnosticDescriptor("RIC0002",
                                        $"Custom get-accessor found for Name-Property of type {typeSymbol}.",
                                        "", "Usage", DiagnosticSeverity.Error, true), getAccessor.Body.GetLocation()));
                            return;
                        }

                        compName = literalExpressionSyntax.Token.Text;
                    }
                    else
                    {
                        context.ReportDiagnostic(
                            Diagnostic.Create(
                                new DiagnosticDescriptor("RIC0002",
                                    $"Unknown get-accessor format found for Name-Property of type {typeSymbol}.",
                                    "", "Usage", DiagnosticSeverity.Error, true), getAccessor.GetLocation()));
                        return;
                    }
                }
                else
                {
                    context.ReportDiagnostic(
                        Diagnostic.Create(
                            new DiagnosticDescriptor("RIC0002",
                                $"Unknown Name-Property format found for type {typeSymbol}.",
                                "", "Usage", DiagnosticSeverity.Error, true), nameProperty.GetLocation()));
                    return;
                }

                componentNames.Add(compName);
            }

            var ignoredCompCode = $@"// <auto-generated />
namespace Content.AutoGenerated
{{
    public static class IgnoredComponents
    {{
        public static string[] List => new [] {{
{string.Join(",\n", componentNames)}
        }}
    }}
}}";
            context.AddSource("IgnoredComponents", ignoredCompCode);
        }
    }
}
