using System.Runtime.CompilerServices;
using Content.Shared.Chemistry.Components;
using Content.Shared.Chemistry.Reagent;
using Content.Shared.Database;
using Content.Shared.FixedPoint;
using Robust.Shared.Audio;
using Robust.Shared.Prototypes;
using Robust.Shared.Serialization.TypeSerializers.Implementations.Custom.Prototype;

namespace Content.Shared.Chemistry.Reaction;

/// <summary>
/// Prototype for chemical reaction definitions
/// </summary>
[Prototype("reaction")]
public sealed class ReactionPrototype : ReactionSpecification, IPrototype {}

[DataDefinition]
[ImplicitDataDefinitionForInheritors]
public abstract class ReactionSpecification : IComparable<ReactionSpecification>
{
    [ViewVariables]
    [IdDataFieldAttribute]
    public string ID { get; } = default!;

    /// <summary>
    /// What the reaction is referred to as in user interfaces.
    /// </summary>
    [DataField("name")]
    public string Name { get; } = string.Empty;

    /// <summary>
    /// The speed at which the reaction progresses in solution.
    /// Infinite reaction speed indicates that the reaction should complete instantly when it can react.
    /// </summary>
    [DataField("rate")]
    [ViewVariables(VVAccess.ReadWrite)]
    [Access(typeof(SharedChemicalReactionSystem))]
    public float ReactionRate { get; internal set; } = float.PositiveInfinity;

    /// <summary>
    /// If true, this reaction will only consume only integer multiples of the reactant amounts. If there are not
    /// enough reactants, the reaction does not occur. Useful for spawn-entity reactions (e.g. creating cheese).
    /// Note that if the reaction has a finite <see cref="ReactionRate"/> and is also quantized it will silently
    /// proceed in the background and only cause visible effects when it has progressed enough to consume at least
    /// an integer multiple amount of the reactants.
    /// </summary>
    [DataField("quantized")]
    [ViewVariables(VVAccess.ReadWrite)]
    [Access(typeof(SharedChemicalReactionSystem))]
    public bool Quantized { get; internal set; } = false;

    /// <summary>
    /// The set of reagents required by the reaction.
    /// </summary>
    [DataField("reactants", required:true)]
    [ViewVariables(VVAccess.ReadOnly)]
    public readonly List<ReactantSpecification> Reactants = new();

    /// <summary>
    /// The set of reagents produced by the reaction.
    /// </summary>
    [DataField("products")]
    [ViewVariables(VVAccess.ReadOnly)]
    public readonly List<ProductSpecification> Products = new();

    /// <summary>
    /// The total change in solution volume caused per unit of this reaction.
    /// </summary>
    [ViewVariables(VVAccess.ReadOnly)]
    public FixedPoint2 VolumeDelta = FixedPoint2.Zero;

    /// <summary>
    /// Whether or not this reaction is allowed to overflow its container.
    /// </summary>
    [DataField("canOverflow")]
    [ViewVariables(VVAccess.ReadWrite)]
    public bool CanOverflow = false;

    #region Thermodynamics

    /// <summary>
    /// The minimum temperature required for this reaction to occur.
    /// </summary>
    [DataField("minTemp")]
    [ViewVariables(VVAccess.ReadWrite)]
    [Access(typeof(SharedChemicalReactionSystem))]

    public float MinimumTemperature = 0f;

    /// <summary>
    /// The maximum temperature required for this reaction to occur.
    /// </summary>
    [DataField("maxTemp")]
    [ViewVariables(VVAccess.ReadWrite)]
    [Access(typeof(SharedChemicalReactionSystem))]
    public float MaximumTemperature = float.PositiveInfinity;

    /// <summary>
    /// The amount of heat generated by this reaction.
    /// </summary>
    [DataField("heat")]
    [ViewVariables(VVAccess.ReadWrite)]
    [Access(typeof(SharedChemicalReactionSystem))]
    public float HeatDelta = 0;

    /// <summary>
    /// The amount of heat capacity added or removed from the solution per reaction unit.
    /// Automatically calculated from the reactants and products.
    /// </summary>
    [ViewVariables(VVAccess.ReadOnly)]
    [Access(typeof(SharedChemicalReactionSystem))]
    public float HeatCapacityDelta = 0;

    /// <summary>
    /// The temperature of the reagents produced by this reaction.
    /// Autogenerated from the produced heat and produced reagents because <see cref="Solution.HeatCapacity"/> is expensive.
    ///
    /// The produced thermal energy and the produced heat capacity have the same scaling factor.
    /// The result is that it effectively produces its products at a specific temperature.
    /// This is the temperature the solution would approach if it were to progress forever.
    /// If the reaction instead consumes all of the reagents in the solution as reactants it will instead approach
    ///     T = (T0*C_down + dU) / C_up; where
    ///     T0 = The intial temperature of the reactants.
    ///     C_down = The heat capacity of the reactants consumed per unit reaction.
    ///     dU = The thermal energy produced per unit reaction.
    ///     C_up = The heat capacity of the products produced per unit reaction.
    /// Note that this can be negative, this is fine. It will be merged into the target solution pretty soon at which point that will cease to be a problem.
    /// </summary>
    [ViewVariables(VVAccess.ReadOnly)]
    [Access(typeof(SharedChemicalReactionSystem))]
    public float ProductTemperature = 0;

    #endregion Thermodynamics

    #region Mixing

    /// <summary>
    /// The required mixing categories for an entity to mix the solution with for the reaction to occur
    /// </summary>
    [DataField("requiredMixerCategories")]
    [ViewVariables(VVAccess.ReadWrite)]
    public List<string>? MixingCategories = null;

    /// <summary>
    /// Whether this reaction requires that it be continuously mixed to keep reacting.
    /// </summary>
    [DataField("needsContinuousMixing")]
    [ViewVariables(VVAccess.ReadWrite)]
    public bool NeedsContinuousMixing = true;

    #endregion Mixing

    #region Effects

    /// <summary>
    /// The set of effects that this reaction has when it begins to occur.
    /// </summary>
    [DataField("startEffects", serverOnly: true)]
    [ViewVariables(VVAccess.ReadOnly)]
    [Access(typeof(SharedChemicalReactionSystem))]
    public List<ReagentEffect> StartEffects = new();

    /// <summary>
    /// The set of effects that this reaction has periodically as is occurs.
    /// </summary>
    [DataField("stepEffects", serverOnly: true)]
    [ViewVariables(VVAccess.ReadOnly)]
    [Access(typeof(SharedChemicalReactionSystem))]
    public List<ReagentEffect> StepEffects = new();

    /// <summary>
    /// The set of effects that this reaction has when it ceases to occur.
    /// </summary>
    [DataField("stopEffects", serverOnly: true)]
    [ViewVariables(VVAccess.ReadOnly)]
    [Access(typeof(SharedChemicalReactionSystem))]
    public List<ReagentEffect> StopEffects = new();

    #endregion Effects

    #region Priority

    /// <summary>
    /// Determines the order in which reactions occur. This should used to ensure that (in general) descriptive /
    /// pop-up generating and explosive reactions occur before things like foam/area effects.
    /// </summary>
    [DataField("priority")]
    [ViewVariables(VVAccess.ReadWrite)]
    [Access(typeof(SharedChemicalReactionSystem))]
    public int Priority = 0;

    /// <summary>
    /// Comparison for creating a sorted set of reactions. Determines the order in which reactions occur.
    /// </summary>
    public virtual int CompareTo(ReactionSpecification? other)
    {
        if (other == null)
            return -1;

        if (Priority != other.Priority)
            return other.Priority - Priority;

        // Prioritize reagents that don't generate products. This should reduce instances where a solution
        // temporarily overflows and discards products simply due to the order in which the reactions occurred.
        // Basically: Make space in the beaker before adding new products.
        if (Products.Count != other.Products.Count)
            return Products.Count - other.Products.Count;

        return ID.CompareTo(other.ID);
    }

    #endregion Priority

    #region Logging

    /// <summary>
    /// How dangerous is this effect? Stuff like bicaridine should be low, while things like methamphetamine
    /// or potas/water should be high.
    /// </summary>
    [DataField("impact", serverOnly: true)] public LogImpact Impact = LogImpact.Low;

    // TODO SERV3: Empty on the client, (de)serialize on the server with module manager is server module
    [DataField("sound", serverOnly: true)] public SoundSpecifier Sound { get; private set; } = new SoundPathSpecifier("/Audio/Effects/Chemistry/bubbles.ogg");

    #endregion Logging
}

/// <summary>
/// A specification for a reagent required by a reaction.
/// </summary>
[DataDefinition]
public sealed class ReactantSpecification
{
    /// <summary>
    /// The id of the reagent required by the reaction.
    /// </summary>
    [DataField("id", required:true, customTypeSerializer:typeof(PrototypeIdSerializer<ReagentPrototype>))]
    [ViewVariables(VVAccess.ReadWrite)]
    public string Id = default!;

    /// <summary>
    /// The amount of the reagent required by the reaction per reaction unit.
    /// </summary>
    [DataField("amount")]
    [ViewVariables(VVAccess.ReadWrite)]
    public FixedPoint2 Amount = 1;

    /// <summary>
    /// Whether or not the reactant is a catalyst. Catalysts aren't consumed when a reaction occurs.
    /// </summary>
    [DataField("catalyst")]
    [ViewVariables(VVAccess.ReadWrite)]
    public bool Catalyst = false;
}

/// <summary>
/// A specification for a reagent produced by a reaction.
/// </summary>
[DataDefinition]
public sealed class ProductSpecification
{
    /// <summary>
    /// The id of the reagent produced by the reaction.
    /// </summary>
    [DataField("id", required:true, customTypeSerializer:typeof(PrototypeIdSerializer<ReagentPrototype>))]
    [ViewVariables(VVAccess.ReadWrite)]
    public string Id = default!;

    /// <summary>
    /// The amount of the reagent produced by the reaction per reaction unit.
    /// </summary>
    [DataField("amount")]
    [ViewVariables(VVAccess.ReadWrite)]
    public FixedPoint2 Amount = 1;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Deconstruct(out string id, out FixedPoint2 amount)
    {
        id = Id;
        amount = Amount;
    }
}
