using Content.Client.Viewport;
using Content.Shared.SurveillanceCamera;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.CustomControls;
using Robust.Client.UserInterface.XAML;

namespace Content.Client.SurveillanceCamera.UI;

[GenerateTypedNameReferences]
public sealed partial class SurveillanceCameraMonitorWindow : DefaultWindow
{
    public event Action<string>? CameraSelected;
    public event Action<string>? SubnetOpened;

    public SurveillanceCameraMonitorWindow()
    {
        RobustXamlLoader.Load(this);

        SubnetSelector.OnItemSelected += args =>
        {
            // piss
            SubnetOpened!((string) args.Button.SelectedMetadata!);
        };
    }

    // The UI class should get the eye from the entity, and then
    // pass it here so that the UI can change its view.
    public void UpdateState(IEye? eye, List<string> subnets)
    {
        CameraView.Eye = eye;

        // if the subnet count is unequal, that means
        // we have to rebuild the subnets
        if (SubnetSelector.ItemCount != subnets.Count)
        {
            SubnetSelector.Clear();
            SubnetList.DisposeAllChildren();
            SubnetList.RemoveAllChildren();

            foreach (var subnet in subnets)
            {
                AddSubnet(subnet);
            }
        }
    }

    private int AddSubnet(string subnet)
    {
        SubnetSelector.AddItem(subnet);
        SubnetSelector.SetItemMetadata(SubnetSelector.ItemCount - 1, subnet);

        return SubnetSelector.ItemCount - 1;
    }

    // When a subnet is queried from the client UI, it should
    // populate that subnet's tree with the nodes that indicate
    // the cameras in that subnet.
    //
    // The issue with this is that this would require caching in the
    // camera system itself, which... is that ideal to do? Is it OK?
    // I don't have a problem treating the system like a true
    // singleton for just a simple cache, but the issue relates to
    // if the DeviceNet portion of it should be axed or not.
    public void SubnetSelected(List<SurveillanceCameraInfo> subnetInfo)
    {
        if (subnetInfo.Count == 0)
        {
            return;
        }

        var subnet = subnetInfo[0].Subnet;

        if (SubnetSelector.SelectedMetadata == null
            || subnet != (string) SubnetSelector.SelectedMetadata)
        {
            return;
        }

        foreach (var camera in subnetInfo)
        {
            if (camera.Subnet != subnet)
            {
                continue;
            }

            var button = CreateCameraButton(camera.Name, camera.Address);

            SubnetList.AddChild(button);
        }
    }

    private Button CreateCameraButton(string name, string address)
    {
        var button = new Button()
        {
            Text = name
        };

        button.OnPressed += _ => CameraSelected!(address);

        return button;
    }
}
