using Content.Client.Viewport;
using Content.Shared.SurveillanceCamera;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.CustomControls;
using Robust.Client.UserInterface.XAML;

namespace Content.Client.SurveillanceCamera.UI;

[GenerateTypedNameReferences]
public sealed partial class SurveillanceCameraMonitorWindow : DefaultWindow
{
    public event Action<string>? CameraSelected;
    public event Action<string>? SubnetOpened;
    public event Action? CameraRefresh;
    public event Action? SubnetRefresh;

    private ScalingViewport? _cameraView;

    private string? SelectedSubnet
    {
        get
        {
            if (SubnetSelector.ItemCount == 0
                || SubnetSelector.SelectedMetadata == null)
            {
                return null;
            }

            return (string) SubnetSelector.SelectedMetadata;
        }
    }

    public SurveillanceCameraMonitorWindow()
    {
        RobustXamlLoader.Load(this);

        SubnetSelector.OnItemSelected += args =>
        {
            // piss
            SubnetOpened!((string) args.Button.SelectedMetadata!);
        };
        SubnetRefreshButton.OnPressed += _ => SubnetRefresh!();
        CameraRefreshButton.OnPressed += _ => CameraRefresh!();
    }

    // The UI class should get the eye from the entity, and then
    // pass it here so that the UI can change its view.
    public void UpdateState(IEye? eye, HashSet<string> subnets, string activeSubnet, IReadOnlySet<SurveillanceCameraInfo> cameras)
    {
        SetCameraView(eye);

        if (SelectedSubnet != null && activeSubnet != SelectedSubnet)
        {
            SubnetList.DisposeAllChildren();
            SubnetList.RemoveAllChildren();
        }

        // if the subnet count is unequal, that means
        // we have to rebuild the subnet selector
        if (SubnetSelector.ItemCount != subnets.Count)
        {
            SubnetSelector.Clear();

            foreach (var subnet in subnets)
            {
                var id = AddSubnet(subnet);
                if (subnet == activeSubnet)
                {
                    SubnetSelector.Select(id);
                }
            }
        }

        PopulateCameraList(cameras);
    }

    private void PopulateCameraList(IReadOnlySet<SurveillanceCameraInfo> cameras)
    {
        foreach (var camera in cameras)
        {
            if (camera.Subnet != SelectedSubnet)
            {
                continue;
            }

            AddCameraToList(camera.Name, camera.Address);
        }
    }

    private void SetCameraView(IEye? eye)
    {
        if (eye == null)
        {
            CameraViewBox.DisposeAllChildren();
            CameraViewBox.RemoveAllChildren();
            _cameraView = null;
        }
        else if (_cameraView != null)
        {
            _cameraView.Eye = eye;
        }
        else
        {
            _cameraView = new()
            {
                ViewportSize = new Vector2i(500, 500),
                VerticalExpand = true,
                HorizontalExpand = true,
                MinSize = new Vector2(500, 500),
                Eye = eye,
                MouseFilter = MouseFilterMode.Ignore
            };
            CameraViewBox.AddChild(_cameraView);
        }
    }

    private int AddSubnet(string subnet)
    {
        SubnetSelector.AddItem(subnet);
        SubnetSelector.SetItemMetadata(SubnetSelector.ItemCount - 1, subnet);

        return SubnetSelector.ItemCount - 1;
    }

    public void AddCameraToList(string name, string address)
    {
        var button = CreateCameraButton(name, address);
        SubnetList.AddChild(button);
    }

    private Button CreateCameraButton(string name, string address)
    {
        var button = new Button()
        {
            Text = name
        };

        button.OnPressed += _ => CameraSelected!(address);

        return button;
    }
}
