using Content.Client.Guidebook.Richtext;
using Content.Client.UserInterface.Controls;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.ContentPack;
using System.Linq;

namespace Content.Client.Guidebook.Controls;

[GenerateTypedNameReferences]
public sealed partial class GuidebookWindow : FancyWindow
{
    [Dependency] private readonly IResourceManager _resourceManager = default!;
    [Dependency] private readonly GuidebookParsingManager _parsingMan = default!;

    private Dictionary<string, GuideEntry> _entries = new();
    private string? _currentlyShowing;

    public GuidebookWindow()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);

        Tree.OnItemSelected += GuideSelectOnOnItemSelected;
    }

    public void ClearSelecteddGuide()
    {
        _currentlyShowing = null;
        Placeholder.Visible = true;
        EntryContainer.RemoveAllChildren();
    }

    private void GuideSelectOnOnItemSelected() =>
        ShowGuide((GuideEntry) Tree.Selected!.Metadata!);

    private void ShowGuide(GuideEntry entry)
    {
        _currentlyShowing = entry.Id;
        Placeholder.Visible = false;
        EntryContainer.RemoveAllChildren();
        using var file = _resourceManager.ContentFileReadText(entry.Text);

        EntryContainer.AddChild(new Label()
        {
            StyleClasses = { "LabelHeadingBigger" },
            Text = Loc.GetString(entry.Name)
        }); ;

        var doc = new Document();
        EntryContainer.AddChild(doc);

        if (!_parsingMan.TryAddMarkup(doc, file.ReadToEnd()))
            Logger.Error($"Failed to add contents of guide document {entry.Id}.");

        EntryContainer.MaxWidth = Size.X * (2.0f / 3.0f) - 20.0f * UIScale;
    }

    public void UpdateGuides(
        Dictionary<string, GuideEntry> entries,
        List<string>? rootEntries = null,
        string? forceRoot = null,
        string? selected = null)
    {
        _entries = entries;
        RepopulateTree(rootEntries, forceRoot);

        // why doesn't tree allow you to set the selected entry!?!? Or even retrieve existing entries???
        // TODO fix tree shitcode and then just show the singular entry

        if (Tree.ChildCount > 1)
        {
            // TODO hide tree view altogether
            // selected = WhyTheFuckDoesntTheTreeHaveAMethodToGetFuckingItems()
        }

        if (selected != null)
        {
            // TODO select guide. Inc making it highlighted in the tree
            return;
        }

        if (_currentlyShowing != null && !entries.ContainsKey(_currentlyShowing))
            ClearSelecteddGuide();
        else
        {
            // TODO select the currently shown item (so that it is highlighted in the tree/TOC.
        }
    }

    private IEnumerable<GuideEntry> GetSortedRootEntries(List<string>? rootEntries)
    {
        if (rootEntries == null)
        {
            HashSet<string> entries = new(_entries.Keys);
            foreach (var entry in _entries.Values)
            {
                entries.ExceptWith(entry.Children);
            }
            rootEntries = entries.ToList();
        }

        return rootEntries
            .Select(x => _entries[x])
            .OrderBy(x => x.Priority)
            .ThenBy(x => Loc.GetString(x.Name));
    }

    private void RepopulateTree(List<string>? roots = null, string? forcedRoot = null)
    {
        Tree.Clear();

        HashSet<string> addedEntries = new();

        Tree.Item? parent = forcedRoot == null ? null : AddEntry(forcedRoot, null, addedEntries, false);
        foreach (var entry in GetSortedRootEntries(roots))
        {
            AddEntry(entry.Id, parent, addedEntries, parent != null);
        }
    }

    private Tree.Item? AddEntry(string id, Tree.Item? parent, HashSet<string> addedEntries, bool indent)
    {
        if (!_entries.TryGetValue(id, out var entry))
            return null;

        if (!addedEntries.Add(id))
        {
            Logger.Error($"Adding duplicate guide entry: {id}");
            return null;
        }

        var item = Tree.CreateItem(parent);
        item.Metadata = entry;
        var name = Loc.GetString(entry.Name);
        item.Text = indent ? $"â€º {name}" : name;

        foreach (var child in entry.Children)
        {
            AddEntry(child, item, addedEntries, true);
        }

        return item;
    }
}
