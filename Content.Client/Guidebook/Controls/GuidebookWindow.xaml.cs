using Content.Client.Guidebook.Richtext;
using Content.Client.UserInterface.Controls;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.ContentPack;
using System.Linq;

namespace Content.Client.Guidebook.Controls;

[GenerateTypedNameReferences]
public sealed partial class GuidebookWindow : FancyWindow
{
    [Dependency] private readonly IResourceManager _resourceManager = default!;
    [Dependency] private readonly GuidebookParsingManager _parsingMan = default!;

    private Dictionary<string, GuideEntry> _entries = new();

    public GuidebookWindow()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);

        Tree.OnItemSelected += GuideSelectOnOnItemSelected;
    }

    private void GuideSelectOnOnItemSelected() =>
        ShowGuide((GuideEntry) Tree.Selected!.Metadata!);

    private void ShowGuide(GuideEntry entry)
    {
        EntryContainer.RemoveAllChildren();
        using var file = _resourceManager.ContentFileReadText(entry.Text);

        EntryContainer.AddChild(new Label()
        {
            StyleClasses = { "LabelHeadingBigger" },
            Text = Loc.GetString(entry.Name)
        }); ;

        var doc = new Document();
        EntryContainer.AddChild(doc);

        if (!_parsingMan.TryAddMarkup(doc, file.ReadToEnd()))
            Logger.Error($"Failed to add contents of guide document {entry.Id}.");

        EntryContainer.MaxWidth = Size.X * (2.0f / 3.0f) - 20.0f * UIScale;
    }

    public void UpdateGuides(Dictionary<string, GuideEntry> entries, List<string>? rootEntries = null, string? forceRoot = null)
    {
        _entries = entries;
        RepopulateTree(rootEntries, forceRoot);

        if (Tree.ChildCount > 1)
            return;

        // why doesn't tree allow you to set the selected entry!?!? Or even retrieve existing entries???
        // TODO fix tree shitcode and then just show the singular entry

        // Tree.Visible = false;
        // ShowGuide((GuideEntry) ((Tree.Item)Tree.Children.First()).Metadata);
        ;
    }

    private IEnumerable<GuideEntry> GetSortedRootEntries(List<string>? rootEntries)
    {
        if (rootEntries == null)
        {
            HashSet<string> entries = new(_entries.Keys);
            foreach (var entry in _entries.Values)
            {
                entries.ExceptWith(entry.Children);
            }
            rootEntries = entries.ToList();
        }

        return rootEntries
            .Select(x => _entries[x])
            .OrderBy(x => x.Priority)
            .ThenBy(x => Loc.GetString(x.Name));
    }

    private void RepopulateTree(List<string>? roots = null, string? forcedRoot = null)
    {
        Tree.Clear();

        HashSet<string> addedEntries = new();

        Tree.Item? parent = forcedRoot == null ? null : AddEntry(forcedRoot, null, addedEntries, false);
        foreach (var entry in GetSortedRootEntries(roots))
        {
            AddEntry(entry.Id, parent, addedEntries, parent != null);
        }
    }

    private Tree.Item? AddEntry(string id, Tree.Item? parent, HashSet<string> addedEntries, bool indent)
    {
        if (!_entries.TryGetValue(id, out var entry))
        {
            Logger.Error($"Missing guide entry: {id}");
            return null;
        }

        if (!addedEntries.Add(id))
        {
            Logger.Error($"Adding duplicate guide entry: {id}");
            return null;
        }

        var item = Tree.CreateItem(parent);
        item.Metadata = entry;
        var name = Loc.GetString(entry.Name);
        item.Text = indent ? $"â€º {name}" : name;

        foreach (var child in entry.Children)
        {
            AddEntry(child, item, addedEntries, true);
        }

        return item;
    }
}
