using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Timing;
using Robust.Shared.Utility;

namespace Content.Client.UserInterface.Controls;

/// <summary>
///     Functionally similar to <see cref="Tree"/>, but with collapsible sections, 
/// </summary>

[GenerateTypedNameReferences]
public sealed partial class FancyTree : Control
{
    public int Indentation = 16;
    public readonly List<TreeItem> Items = new();

    public event Action<TreeItem?>? OnSelectedItemChanged;

    public int? SelectedIndex { get; private set; }

    private bool _rowStyleUpdateQueued = true;

    public TreeItem? SelectedItem => SelectedIndex == null ? null : Items[SelectedIndex.Value];

    /// <summary>
    ///     If true, a collapsed item will automatically expand when first selected. If false, it has to be manually expanded by
    ///     clicking on it a second time.
    /// </summary>
    public bool AutoExpand = true;

    public FancyTree()
    {
        RobustXamlLoader.Load(this);
    }

    public TreeItem AddItem(TreeItem? parent = null)
    {
        if (parent != null)
        {
            if (parent.Tree != this)
                throw new ArgumentException("Parent must be owned by this tree.", nameof(parent));

            DebugTools.Assert(Items[parent.Index] == parent);
        }

        var item = new TreeItem()
        {
            Tree = this,
            Index = Items.Count,
        };

        item.IconBox.SetSize = (Indentation, Indentation);
        Items.Add(item);
        item.Button.OnPressed += (_) => OnPressed(item);

        if (parent == null)
            Body.AddChild(item);
        else
        {
            var margin = parent.IconBox.Margin;
            margin.Left += Indentation;
            item.IconBox.Margin = margin;
            parent.Body.AddChild(item);
        }

        QueueRowStyleUpdate();
        return item;
    }

    private void OnPressed(TreeItem item)
    {
        if (SelectedIndex == item.Index)
        {
            item.SetExpanded(!item.Expanded);
            return;
        }

        SetSelectedIndex(item.Index);
    }

    public void SetSelectedIndex(int? value)
    {
        if (value == null || value < 0 || value >= Items.Count)
            value = null;

        if (SelectedIndex == value)
            return;

        SelectedItem?.SetSelected(false);
        SelectedIndex = value;

        var newSelection = SelectedItem;
        if (newSelection != null)
        {
            newSelection.SetSelected(true);
            if (AutoExpand && !newSelection.Expanded)
                newSelection.SetExpanded(true);
        }

        OnSelectedItemChanged?.Invoke(newSelection);
    }

    public void SetAllExpanded(bool value)
    {
        foreach (var item in Body.Children)
        {
            RecursiveSetExpanded((TreeItem) item, value);
        }
    }

    public void RecursiveSetExpanded(TreeItem item, bool value)
    {
        item.SetExpanded(value);
        foreach (var child in item.Body.Children)
        {
            RecursiveSetExpanded((TreeItem) child, value);
        }
    }

    public void Clear()
    {
        foreach (var item in Items)
        {
            item.Dispose();
        }

        Items.Clear();
        Body.Children.Clear();
        SelectedIndex = null;
    }

    public void QueueRowStyleUpdate()
    {
        _rowStyleUpdateQueued = true;
    }

    protected override void FrameUpdate(FrameEventArgs args)
    {
        if (!_rowStyleUpdateQueued)
            return;

        _rowStyleUpdateQueued = false;

        int index = 0;

        foreach (var item in Body.Children)
        {
            RecursivelyUpdateRowStyle((TreeItem) item, ref index);
        }
    }

    private void RecursivelyUpdateRowStyle(TreeItem item, ref int index)
    {
        if (int.IsOddInteger(index))
        {
            item.Button.RemoveStyleClass(TreeItem.StyleClassEvenRow);
            item.Button.AddStyleClass(TreeItem.StyleClassOddRow);
        }
        else
        {
            item.Button.AddStyleClass(TreeItem.StyleClassEvenRow);
            item.Button.RemoveStyleClass(TreeItem.StyleClassOddRow);
        }

        index++;

        foreach (var child in item.Body.Children)
        {
            RecursivelyUpdateRowStyle((TreeItem) child, ref index);
        }
    }
}
