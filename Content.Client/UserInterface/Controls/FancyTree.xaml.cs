using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Timing;
using Robust.Shared.Utility;

namespace Content.Client.UserInterface.Controls;

/// <summary>
///     Functionally similar to <see cref="Tree"/>, but with collapsible sections, 
/// </summary>

[GenerateTypedNameReferences]
public sealed partial class FancyTree : Control
{
    public readonly List<TreeItem> Items = new();

    public event Action<TreeItem?>? OnSelectedItemChanged;

    public int? SelectedIndex { get; private set; }

    private bool _rowStyleUpdateQueued = true;

    /// <summary>
    ///     Whether or not to draw the lines connecting parents & children.
    /// </summary>
    public bool DrawLines = true;

    // TODO this should be a style parameter for trees & tree-items, with tree-items defaulting to the tree's value.
    public Color LineColor = Color.White;

    // TODO this should be a style parameter for trees & tree-items, with tree-items defaulting to the tree's value.
    public int LineWidth = 2;

    // TODO again this should probably have a style property, in addition to getters & setters.
    public const int Indentation = 16;

    /// <summary>
    ///     Whether to align child entries based on the button text. If true, this means that entries without children
    ///     will effectively have some padding due to the invisible expansion icon.
    /// </summary>
    public bool AlignText
    {
        get => _alignText;
        set => SetAlignText(value);
    }

    private bool _alignText = true;

    public TreeItem? SelectedItem => SelectedIndex == null ? null : Items[SelectedIndex.Value];

    /// <summary>
    ///     If true, a collapsed item will automatically expand when first selected. If false, it has to be manually expanded by
    ///     clicking on it a second time.
    /// </summary>
    public bool AutoExpand = true;

    public FancyTree()
    {
        RobustXamlLoader.Load(this);
    }

    public TreeItem AddItem(TreeItem? parent = null)
    {
        if (parent != null)
        {
            if (parent.Tree != this)
                throw new ArgumentException("Parent must be owned by this tree.", nameof(parent));

            DebugTools.Assert(Items[parent.Index] == parent);
        }

        var item = new TreeItem()
        {
            Tree = this,
            Index = Items.Count,
        };

        item.IconBox.SetSize = (Indentation, Indentation);
        Items.Add(item);
        item.Button.OnPressed += (_) => OnPressed(item);

        if (parent == null)
            Body.AddChild(item);
        else
        {
            item.Padding.MinWidth = parent.Padding.MinWidth + Indentation;
            parent.Body.AddChild(item);
        }

        item.IconBox.Visible = _alignText;
        QueueRowStyleUpdate();
        return item;
    }

    private void OnPressed(TreeItem item)
    {
        if (SelectedIndex == item.Index)
        {
            item.SetExpanded(!item.Expanded);
            return;
        }

        SetSelectedIndex(item.Index);
    }

    public void SetSelectedIndex(int? value)
    {
        if (value == null || value < 0 || value >= Items.Count)
            value = null;

        if (SelectedIndex == value)
            return;

        SelectedItem?.SetSelected(false);
        SelectedIndex = value;

        var newSelection = SelectedItem;
        if (newSelection != null)
        {
            newSelection.SetSelected(true);
            if (AutoExpand && !newSelection.Expanded)
                newSelection.SetExpanded(true);
        }

        OnSelectedItemChanged?.Invoke(newSelection);
    }

    public void SetAllExpanded(bool value)
    {
        foreach (var item in Body.Children)
        {
            RecursiveSetExpanded((TreeItem) item, value);
        }
    }

    public void RecursiveSetExpanded(TreeItem item, bool value)
    {
        item.SetExpanded(value);
        foreach (var child in item.Body.Children)
        {
            RecursiveSetExpanded((TreeItem) child, value);
        }
    }

    public void Clear()
    {
        foreach (var item in Items)
        {
            item.Dispose();
        }

        Items.Clear();
        Body.Children.Clear();
        SelectedIndex = null;
    }

    public void QueueRowStyleUpdate()
    {
        _rowStyleUpdateQueued = true;
    }

    protected override void FrameUpdate(FrameEventArgs args)
    {
        if (!_rowStyleUpdateQueued)
            return;

        _rowStyleUpdateQueued = false;

        int index = 0;

        foreach (var item in Body.Children)
        {
            RecursivelyUpdateRowStyle((TreeItem) item, ref index);
        }
    }

    private void RecursivelyUpdateRowStyle(TreeItem item, ref int index)
    {
        if (int.IsOddInteger(index))
        {
            item.Button.RemoveStyleClass(TreeItem.StyleClassEvenRow);
            item.Button.AddStyleClass(TreeItem.StyleClassOddRow);
        }
        else
        {
            item.Button.AddStyleClass(TreeItem.StyleClassEvenRow);
            item.Button.RemoveStyleClass(TreeItem.StyleClassOddRow);
        }

        index++;

        if (!item.Expanded)
            return;

        foreach (var child in item.Body.Children)
        {
            RecursivelyUpdateRowStyle((TreeItem) child, ref index);
        }
    }

    private void SetAlignText(bool value)
    {
        if (_alignText == value)
            return;

        _alignText = value;

        foreach (var child in Body.Children)
        {
            RecursivelyUpdateAlignment((TreeItem) child);
        }
    }

    private void RecursivelyUpdateAlignment(TreeItem item)
    {
        if (item.Body.ChildCount == 0 || !item.Collapsible)
        {
            // hide icon box. If the box is visible, all text should be aligned.
            item.IconBox.Visible = _alignText;
            return;
        }
         
        foreach (var child in item.Body.Children)
        {
            RecursivelyUpdateAlignment((TreeItem) child);
        }
    }
}
