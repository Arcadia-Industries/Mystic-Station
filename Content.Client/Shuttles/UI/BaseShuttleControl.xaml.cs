using System.Linq;
using Content.Client.UserInterface.Controls;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.ResourceManagement;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Collections;
using Robust.Shared.Map.Components;
using Robust.Shared.Physics;
using Robust.Shared.Threading;
using Robust.Shared.Timing;
using Robust.Shared.Utility;
using Vector2 = System.Numerics.Vector2;

namespace Content.Client.Shuttles.UI;

/// <summary>
/// Provides common functionality for radar-like displays on shuttle consoles.
/// </summary>
[GenerateTypedNameReferences]
[Virtual]
public partial class BaseShuttleControl : MapGridControl
{
    [Dependency] private readonly IParallelManager _parallel = default!;
    protected SharedMapSystem Maps;

    protected Font Font;

    private GridDrawJob _drawJob;

    // Cache grid drawing data as it can be expensive to build
    public readonly Dictionary<EntityUid, GridDrawData> GridData = new();

    // Per-draw caching
    private readonly List<Vector2i> _gridTileList = new();
    private readonly HashSet<Vector2i> _gridTileSet = new();
    private readonly HashSet<Vector2i> _gridNeighborSet = new();
    private List<List<Vector2>> _allVertices = new();

    private readonly List<(Vector2 Start, Vector2 End)> _edges = new();

    // TODO: Engine PR.
    private (DirectionFlag, Vector2i)[] _neighborDirections;

    public BaseShuttleControl() : this(32f, 32f, 32f)
    {
    }

    public BaseShuttleControl(float minRange, float maxRange, float range) : base(minRange, maxRange, range)
    {
        RobustXamlLoader.Load(this);
        Maps = EntManager.System<SharedMapSystem>();
        Font = new VectorFont(IoCManager.Resolve<IResourceCache>().GetResource<FontResource>("/Fonts/NotoSans/NotoSans-Regular.ttf"), 12);

        _drawJob = new GridDrawJob()
        {
            Control = this,
        };

        // TODO: Engine pr
        _neighborDirections = new (DirectionFlag, Vector2i)[4];

        for (var i = 0; i < 4; i++)
        {
            var dir = (DirectionFlag) Math.Pow(2, i);
            var dirVec = dir.AsDir().ToIntVec();
            _neighborDirections[i] = (dir, dirVec);
        }
    }

    protected void DrawCircles(DrawingHandleScreen handle)
    {
        // Equatorial lines
        var gridLines = Color.LightGray.WithAlpha(0.01f);

        // Each circle is this x distance of the last one.
        const float EquatorialMultiplier = 2f;

        var minDistance = MathF.Pow(EquatorialMultiplier, EquatorialMultiplier * 1.5f);
        var maxDistance = MathF.Pow(2f, EquatorialMultiplier * 6f);
        var cornerDistance = MathF.Sqrt(WorldRange * WorldRange + WorldRange * WorldRange);

        var origin = ScalePosition(-new Vector2(Offset.X, -Offset.Y));
        var distOffset = -24f;

        for (var radius = minDistance; radius <= maxDistance; radius *= EquatorialMultiplier)
        {
            if (radius > cornerDistance)
                continue;

            var color = Color.ToSrgb(gridLines).WithAlpha(0.05f);
            var scaledRadius = MinimapScale * radius;
            var text = $"{radius:0}m";
            var textDimensions = handle.GetDimensions(Font, text, UIScale);

            handle.DrawCircle(origin, scaledRadius, color, false);
            handle.DrawString(Font, ScalePosition(new Vector2(0f, -radius)) - new Vector2(0f, textDimensions.Y), text, color);
        }

        const int gridLinesRadial = 8;

        for (var i = 0; i < gridLinesRadial; i++)
        {
            Angle angle = (Math.PI / gridLinesRadial) * i;
            // TODO: Handle distance properly.
            var aExtent = angle.ToVec() * ScaledMinimapRadius * 1.42f;
            var lineColor = Color.MediumSpringGreen.WithAlpha(0.02f);
            handle.DrawLine(origin - aExtent, origin + aExtent, lineColor);
        }
    }

    protected void DrawGrid(DrawingHandleScreen handle, Matrix3 matrix, Entity<MapGridComponent> grid, Color color, float alpha = 0.01f)
    {
        var rator = Maps.GetAllTilesEnumerator(grid.Owner, grid.Comp);
        var minimapScale = MinimapScale;
        var midpoint = new Vector2(MidPoint, MidPoint);
        var tileSize = grid.Comp.TileSize;

        // Check if we even have data
        // TODO: Need to prune old grid-data if we don't draw it.
        var gridData = GridData.GetOrNew(grid.Owner);

        if (gridData.LastBuild < grid.Comp.LastTileModifiedTick)
        {
            gridData.Edges.Clear();
            gridData.Tris.Clear();
            _gridTileList.Clear();
            _gridTileSet.Clear();
            _gridNeighborSet.Clear();

            // Okay so there's 2 steps to this
            // 1. Is that get we get a set of all tiles. This is used to decompose into triangle-strips
            // 2. Is that we get a list of all tiles. This is used for edge data to decompose into line-strips.
            while (rator.MoveNext(out var tileRef))
            {
                var index = tileRef.Value.GridIndices;
                _gridTileSet.Add(index);
                _gridNeighborSet.Add(index);
                _gridTileList.Add(index);
            }

            while (_gridTileSet.Count > 0)
            {
                var seed = _gridTileSet.First();
                _gridTileSet.Remove(seed);
                var triList = new List<Vector2>();

                // Essentially what we do is make a triangle-strip horizontally similar to how fixtures are made for chunks
                // Using a strip means less verts to be processed compared to a list.
                // Add verts and shit in here, no transform
                var tileVec = Maps.TileToVector(grid, seed);
                var br = tileVec + new Vector2(tileSize, 0f);
                var tr = tileVec + new Vector2(tileSize, tileSize);
                var tl = tileVec + new Vector2(0f, tileSize);

                triList.Add(tileVec);
                triList.Add(tl);
                triList.Add(br);
                triList.Add(tr);

                RecurseTris(grid, _gridTileSet, seed, triList);
                gridData.Tris.Add(triList);
            }

            foreach (var tile in _gridTileList)
            {
                // We get all of the raw lines up front
                // then we decompose them into longer lines in a separate step.
                foreach (var (dir, dirVec) in _neighborDirections)
                {
                    var neighbor = tile + dirVec;

                    if (_gridNeighborSet.Contains(neighbor))
                        continue;

                    // Could probably rotate this but this might be faster?
                    Vector2 actualStart;
                    Vector2 actualEnd;

                    var bl = Maps.TileToVector(grid, tile);
                    var br = bl + new Vector2(tileSize, 0f);
                    var tr = bl + new Vector2(tileSize, tileSize);
                    var tl = bl + new Vector2(0f, tileSize);

                    switch (dir)
                    {
                        case DirectionFlag.South:
                            actualStart = bl;
                            actualEnd = br;
                            break;
                        case DirectionFlag.East:
                            actualStart = br;
                            actualEnd = tr;
                            break;
                        case DirectionFlag.North:
                            actualStart = tr;
                            actualEnd = tl;
                            break;
                        case DirectionFlag.West:
                            actualStart = tl;
                            actualEnd = bl;
                            break;
                        default:
                            throw new NotImplementedException();
                    }

                    // Okay originally I had this as a dictionary but if you have 2 corners
                    // (e.g. BL and TR) then they may both have the same starting vector

                    // If this actually becomes a problem then just add a dictionary that contains the indices
                    // of all entries.
                    _edges.Add((actualStart, actualEnd));
                }
            }

            // Now we decompose the lines into longer lines (less data to send to the GPU)
            var decomposed = true;

            while (decomposed)
            {
                decomposed = false;

                for (var i = 0; i < _edges.Count; i++)
                {
                    var (start, end) = _edges[i];
                    var neighborFound = false;
                    var neighborIndex = 0;
                    Vector2 neighborStart;
                    Vector2 neighborEnd = Vector2.Zero;

                    // Does our end correspond with another start?
                    for (var j = i + 1; j < _edges.Count; j++)
                    {
                        (neighborStart, neighborEnd) = _edges[j];

                        if (!end.Equals(neighborStart))
                            continue;

                        neighborFound = true;
                        neighborIndex = j;
                        break;
                    }

                    if (!neighborFound)
                        continue;

                    // Check if our start and the neighbor's end are collinear
                    if (!CollinearSimplifier.IsCollinear(start, end, neighborEnd, 10f * float.Epsilon))
                        continue;

                    decomposed = true;
                    _edges[i] = (start, neighborEnd);
                    _edges.RemoveAt(neighborIndex);
                }
            }

            // As a final step we'll create linestrips to send even LESS data.
            while (_edges.Count > 0)
            {
                var seed = _edges[^1];
                _edges.RemoveAt(_edges.Count - 1);
                var lineStrip = new List<Vector2>
                {
                    seed.Start,
                    seed.End,
                };

                RecurseLines(lineStrip, _edges, seed.End);

                gridData.Edges.Add(lineStrip);
            }

            gridData.LastBuild = grid.Comp.LastTileModifiedTick;
        }

        var totalData = 0;
        for (var i = 0; i < gridData.Tris.Count; i++)
        {
            if (_allVertices.Count <= i)
            {
                _allVertices.Add(new List<Vector2>());
            }

            var li = _allVertices[i];
            li.Clear();

            for (var j = 0; j < gridData.Tris[i].Count; j++)
            {
                li.Add(Vector2.Zero);
            }

            totalData += gridData.Tris[i].Count;
        }

        // Add tri data first then edges
        _drawJob.MidPoint = midpoint;
        _drawJob.Matrix = matrix;
        _drawJob.MinimapScale = minimapScale;
        _drawJob.Vertices = gridData.Tris;
        _drawJob.ScaledVertices = _allVertices;

        _parallel.ProcessNow(_drawJob, totalData);

        for (var i = 0; i < gridData.Tris.Count; i++)
        {
            var strip = _allVertices[i];
            handle.DrawPrimitives(DrawPrimitiveTopology.TriangleStrip, strip, color.WithAlpha(alpha));
        }

        totalData = 0;
        for (var i = 0; i < gridData.Edges.Count; i++)
        {
            if (_allVertices.Count <= i)
            {
                _allVertices.Add(new List<Vector2>());
            }

            var li = _allVertices[i];
            li.Clear();

            for (var j = 0; j < gridData.Edges[i].Count; j++)
            {
                li.Add(Vector2.Zero);
            }

            totalData += gridData.Edges[i].Count;
        }

        _drawJob.Vertices = gridData.Edges;

        _parallel.ProcessNow(_drawJob, totalData);

        for (var i = 0; i < gridData.Edges.Count; i++)
        {
            var strip = _allVertices[i];
            handle.DrawPrimitives(DrawPrimitiveTopology.LineStrip, strip, color);
        }
    }

    private void RecurseTris(Entity<MapGridComponent> grid, HashSet<Vector2i> tiles, Vector2i tile, List<Vector2> triStrip)
    {
        var tileSize = grid.Comp.TileSize;

        while (true)
        {
            // Check neighbor to see if we can keep going
            var neighbor = tile + Vector2i.Right;

            if (!tiles.Remove(neighbor))
                return;

            var neighborTileVec = Maps.TileToVector(grid, neighbor);

            var neighborBR = neighborTileVec + new Vector2(tileSize, 0f);
            var neighborTR = neighborTileVec + new Vector2(tileSize, tileSize);

            triStrip.Add(neighborBR);
            triStrip.Add(neighborTR);

            tile = neighbor;
        }
    }

    private void RecurseLines(List<Vector2> lineStrip, List<(Vector2 Start, Vector2 End)> edges, Vector2 lastVertex)
    {
        var found = true;

        while (found)
        {
            found = false;

            for (var i = 0; i < edges.Count; i++)
            {
                var (start, end) = edges[i];

                if (!lastVertex.Equals(start))
                    continue;

                var nextVertex = end;
                edges.RemoveAt(i);

                lineStrip.Add(nextVertex);
                lastVertex = nextVertex;
                found = true;
            }
        }
    }

    private record struct GridDrawJob : IParallelRobustJob
    {
        public int BatchSize => 16;

        public BaseShuttleControl Control;
        public float MinimapScale;
        public Vector2 MidPoint;
        public Matrix3 Matrix;

        public List<List<Vector2>> Vertices;
        public List<List<Vector2>> ScaledVertices;

        public void Execute(int index)
        {
            for (var i = 0; i < Vertices.Count; i++)
            {
                var list = Vertices[i];

                // Found our list
                if (index < list.Count)
                {
                    var vert = list[index];
                    var adjustedVert = Matrix.Transform(vert);
                    adjustedVert = adjustedVert with { Y = -adjustedVert.Y };

                    var scaledVert = Control.ScalePosition(adjustedVert, MinimapScale, MidPoint);
                    ScaledVertices[i][index] = scaledVert;
                    return;
                }

                index -= list.Count;
            }
        }
    }
}

public sealed class GridDrawData
{
    /*
     * List of lists because we use LineStrip and TriangleStrip respectively (less data to pass to the GPU).
     */

    public List<List<Vector2>> Edges = new();
    public List<List<Vector2>> Tris = new();

    public GameTick LastBuild;
}
