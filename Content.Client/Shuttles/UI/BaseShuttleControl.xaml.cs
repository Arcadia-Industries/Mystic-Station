using System.Numerics;
using System.Threading;
using Content.Client.UserInterface.Controls;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.ResourceManagement;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Collections;
using Robust.Shared.Map.Components;
using Robust.Shared.Threading;

namespace Content.Client.Shuttles.UI;

/// <summary>
/// Provides common functionality for radar-like displays on shuttle consoles.
/// </summary>
[GenerateTypedNameReferences]
[Virtual]
public partial class BaseShuttleControl : MapGridControl
{
    [Dependency] private readonly IParallelManager _parallel = default!;
    protected SharedMapSystem Maps;

    protected Font Font;

    // Per-draw caching
    private readonly List<Vector2i> _gridTileList = new();
    private readonly HashSet<Vector2i> _gridTileSet = new();

    private GridDrawJob _drawJob;

    /// <summary>
    /// Cache of the scaled positions of every grid tile.
    /// </summary>
    private readonly List<Vector2> _gridScaledTiles = new();
    private readonly List<bool> _inBounds = new();
    private readonly List<DirectionFlag> _neighbors = new();

    // TODO: Engine PR.
    private (DirectionFlag, Vector2i)[] _neighborDirections;

    public BaseShuttleControl() : this(32f, 32f, 32f)
    {
    }

    public BaseShuttleControl(float minRange, float maxRange, float range) : base(minRange, maxRange, range)
    {
        RobustXamlLoader.Load(this);
        Maps = EntManager.System<SharedMapSystem>();
        Font = new VectorFont(IoCManager.Resolve<IResourceCache>().GetResource<FontResource>("/Fonts/NotoSans/NotoSans-Regular.ttf"), 12);

        // TODO: Engine pr
        _neighborDirections = new (DirectionFlag, Vector2i)[4];

        for (var i = 0; i < 4; i++)
        {
            var dir = (DirectionFlag) Math.Pow(2, i);
            var dirVec = dir.AsDir().ToIntVec();
            _neighborDirections[i] = (dir, dirVec);
        }

        _drawJob = new GridDrawJob
        {
            Control = this,
            Neighbors = _neighbors,
            ScaledPositions = _gridScaledTiles,
            InBounds = _inBounds,
            Maps = Maps,
            Tiles = _gridTileList,
            TileSet = _gridTileSet,
            NeighborDirections = _neighborDirections,
        };
    }

    protected void DrawCircles(DrawingHandleScreen handle)
    {
        // Equatorial lines
        var gridLines = Color.LightGray.WithAlpha(0.01f);

        // Each circle is this x distance of the last one.
        const float EquatorialMultiplier = 2f;

        var minDistance = MathF.Pow(EquatorialMultiplier, EquatorialMultiplier * 1.5f);
        var maxDistance = MathF.Pow(2f, EquatorialMultiplier * 6f);
        var cornerDistance = MathF.Sqrt(WorldRange * WorldRange + WorldRange * WorldRange);

        var origin = ScalePosition(-new Vector2(Offset.X, -Offset.Y));
        var distOffset = -24f;

        for (var radius = minDistance; radius <= maxDistance; radius *= EquatorialMultiplier)
        {
            if (radius > cornerDistance)
                continue;

            var color = Color.ToSrgb(gridLines).WithAlpha(0.05f);
            var scaledRadius = MinimapScale * radius;
            var text = $"{radius:0}m";
            var textDimensions = handle.GetDimensions(Font, text, UIScale);

            handle.DrawCircle(origin, scaledRadius, color, false);
            handle.DrawString(Font, ScalePosition(new Vector2(0f, -radius)) - new Vector2(0f, textDimensions.Y), text, color);
        }

        const int gridLinesRadial = 8;

        for (var i = 0; i < gridLinesRadial; i++)
        {
            Angle angle = (Math.PI / gridLinesRadial) * i;
            // TODO: Handle distance properly.
            var aExtent = angle.ToVec() * ScaledMinimapRadius * 1.42f;
            var lineColor = Color.MediumSpringGreen.WithAlpha(0.02f);
            handle.DrawLine(origin - aExtent, origin + aExtent, lineColor);
        }
    }

    protected void DrawGrid(DrawingHandleScreen handle, Matrix3 matrix, Entity<MapGridComponent> grid, Color color, float alpha = 0.01f)
    {
        var rator = Maps.GetAllTilesEnumerator(grid.Owner, grid.Comp);
        var edges = new ValueList<Vector2>();
        var tileTris = new ValueList<Vector2>();
        const bool DrawInterior = true;
        const int TileBatchCount = 512;
        var minimapScale = MinimapScale;
        var midpoint = new Vector2(MidPoint, MidPoint);

        // Cache which tiles exist up front and work with that
        _gridTileList.Clear();
        _gridTileSet.Clear();
        _inBounds.Clear();
        _neighbors.Clear();
        // We don't clear scaled tiles because it gets overridden (sandboxed man's array).

        while (rator.MoveNext(out var tileRef))
        {
            var index = tileRef.Value.GridIndices;
            _gridTileSet.Add(index);
            _gridTileList.Add(index);
            _inBounds.Add(true);
            _neighbors.Add(DirectionFlag.None);
        }

        // Array-like moment.
        if (_gridTileList.Count * 4 > _gridScaledTiles.Count)
        {
            for (var i = _gridScaledTiles.Count; i < _gridTileList.Count * 4; i++)
            {
                _gridScaledTiles.Add(Vector2.Zero);
            }
        }

        // TODO: Engine method
        if (_inBounds.Count < _gridTileList.Count)
        {
            for (var i = _inBounds.Count; i < _gridTileList.Count; i++)
            {
                _inBounds.Add(false);
            }
        }

        if (_neighbors.Count < _gridTileList.Count)
        {
            for (var i = _neighbors.Count; i < _gridTileList.Count; i++)
            {
                _neighbors.Add(DirectionFlag.None);
            }
        }

        var controlBounds = PixelRect;
        var controlBox = new Box2(controlBounds.BottomLeft, controlBounds.TopRight);
        GridDrawJob.InBoundTileCount = 0;
        _drawJob.Bounds = controlBox;
        _drawJob.Grid = grid;
        _drawJob.Matrix = matrix;
        _drawJob.Midpoint = midpoint;
        _drawJob.MinimapScale = minimapScale;
        _drawJob.TileSize = grid.Comp.TileSize;

        _parallel.ProcessNow(_drawJob, _gridTileList.Count);

        for (var i = 0; i < _gridTileList.Count; i++)
        {
            var inBounds = _inBounds[i];

            if (!inBounds)
                continue;

            var scaleIndex = i * 4;

            var scaledBL = _gridScaledTiles[scaleIndex];
            var scaledBR = _gridScaledTiles[scaleIndex + 1];
            var scaledTR = _gridScaledTiles[scaleIndex + 2];
            var scaledTL = _gridScaledTiles[scaleIndex + 3];

            /*
             * You may be wondering what the fuck is going on here.
             * Well you see originally I tried drawing the interiors by fixture, but the problem is
             * you get rounding issues and get noticeable aliasing (at least if you don't overdraw and use alpha).
             * Hence per-tile should alleviate it.
             */

            if (DrawInterior)
            {
                // Draw 2 triangles for the quad.
                tileTris.Add(scaledBL);
                tileTris.Add(scaledBR);
                tileTris.Add(scaledTL);

                tileTris.Add(scaledBR);
                tileTris.Add(scaledTL);
                tileTris.Add(scaledTR);
            }

            var neighborsFlag = _neighbors[i];

            if (neighborsFlag == DirectionFlag.None)
                continue;

            foreach (var (dir, _) in _neighborDirections)
            {
                if ((dir & neighborsFlag) == DirectionFlag.None)
                    continue;

                // Draw line
                // Could probably rotate this but this might be faster?
                Vector2 actualStart;
                Vector2 actualEnd;

                switch (dir)
                {
                    case DirectionFlag.South:
                        actualStart = scaledBL;
                        actualEnd = scaledBR;
                        break;
                    case DirectionFlag.East:
                        actualStart = scaledBR;
                        actualEnd = scaledTR;
                        break;
                    case DirectionFlag.North:
                        actualStart = scaledTR;
                        actualEnd = scaledTL;
                        break;
                    case DirectionFlag.West:
                        actualStart = scaledTL;
                        actualEnd = scaledBL;
                        break;
                    default:
                        throw new NotImplementedException();
                }

                edges.Add(actualStart);
                edges.Add(actualEnd);
            }

            if (tileTris.Count > TileBatchCount)
            {
                FlushGridDraw(handle, ref tileTris, ref edges, color, DrawInterior, alpha);
            }
        }

        FlushGridDraw(handle, ref tileTris, ref edges, color, DrawInterior, alpha);
    }

    private void FlushGridDraw(DrawingHandleScreen handle, ref ValueList<Vector2> tileTris, ref ValueList<Vector2> edges, Color color, bool drawInterior, float alpha)
    {
        if (drawInterior)
        {
            handle.DrawPrimitives(DrawPrimitiveTopology.TriangleList, tileTris.Span, color.WithAlpha(alpha));
        }

        handle.DrawPrimitives(DrawPrimitiveTopology.LineList, edges.Span, color);
        tileTris.Clear();
        edges.Clear();
    }

    /// <summary>
    /// Calculates grid-drawing data in parallel per-tile to be re-used later for draw calls.
    /// </summary>
    private record struct GridDrawJob : IParallelRobustJob
    {
        public int BatchSize => 16;

        public BaseShuttleControl Control;
        public SharedMapSystem Maps;

        public Entity<MapGridComponent> Grid;
        public float MinimapScale;
        public Vector2 Midpoint;
        public Box2 Bounds;
        public (DirectionFlag, Vector2i)[] NeighborDirections;

        public static int InBoundTileCount;
        public Matrix3 Matrix;
        public List<Vector2> ScaledPositions;
        public List<Vector2i> Tiles;
        public HashSet<Vector2i> TileSet;
        public List<bool> InBounds;
        public List<DirectionFlag> Neighbors;
        public ushort TileSize;

        public void Execute(int index)
        {
            var tileIndex = Tiles[index];
            var tileVec = Maps.TileToVector(Grid, tileIndex);
            var bl = tileVec;
            var br = tileVec + new Vector2(TileSize, 0f);
            var tr = tileVec + new Vector2(TileSize, TileSize);
            var tl = tileVec + new Vector2(0f, TileSize);

            var adjustedBL = Matrix.Transform(bl);
            var adjustedBR = Matrix.Transform(br);
            var adjustedTR = Matrix.Transform(tr);
            var adjustedTL = Matrix.Transform(tl);

            var scaledBL = Control.ScalePosition(new Vector2(adjustedBL.X, -adjustedBL.Y), MinimapScale, Midpoint);
            var scaledBR = Control.ScalePosition(new Vector2(adjustedBR.X, -adjustedBR.Y), MinimapScale, Midpoint);
            var scaledTR = Control.ScalePosition(new Vector2(adjustedTR.X, -adjustedTR.Y), MinimapScale, Midpoint);
            var scaledTL = Control.ScalePosition(new Vector2(adjustedTL.X, -adjustedTL.Y), MinimapScale, Midpoint);

            // Skip
            if (!Bounds.Contains(scaledBL) &&
                !Bounds.Contains(scaledBR) &&
                !Bounds.Contains(scaledTR) &&
                !Bounds.Contains(scaledTL))
            {
                InBounds[index] = false;
                return;
            }

            InBounds[index] = true;
            var scaleIndex = index * 4;

            ScaledPositions[scaleIndex] = scaledBL;
            ScaledPositions[scaleIndex + 1] = scaledBR;
            ScaledPositions[scaleIndex + 2] = scaledTR;
            ScaledPositions[scaleIndex + 3] = scaledTL;

            // Handle neighbor drawing.
            // Iterate edges and see which we can draw
            var neighbors = DirectionFlag.None;

            foreach (var (dir, dirVec) in NeighborDirections)
            {
                var neighbor = tileIndex + dirVec;

                if (TileSet.Contains(neighbor))
                    continue;

                neighbors |= dir;
            }

            Neighbors[index] = neighbors;
            Interlocked.Increment(ref InBoundTileCount);
        }
    }
}
