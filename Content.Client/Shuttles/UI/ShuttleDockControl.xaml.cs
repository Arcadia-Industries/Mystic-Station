using System.Numerics;
using Content.Shared.Shuttles.BUIStates;
using Content.Shared.Shuttles.Components;
using Content.Shared.Shuttles.Systems;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Map;
using Robust.Shared.Map.Components;

namespace Content.Client.Shuttles.UI;

[GenerateTypedNameReferences]
public sealed partial class ShuttleDockControl : BaseShuttleControl
{
    [Dependency] private readonly IMapManager _mapManager = default!;
    private readonly SharedShuttleSystem _shuttles;
    private readonly SharedTransformSystem _xformSystem;

    public NetEntity? HighlightedDock;

    public NetEntity? ViewedDock;
    public EntityUid? GridEntity;

    public EntityCoordinates? Coordinates;
    public Angle? Angle;

    public DockingInterfaceState? DockState = null;

    private List<Entity<MapGridComponent>> _grids = new();

    public ShuttleDockControl() : base(8f, 32f, 8f)
    {
        RobustXamlLoader.Load(this);
        _shuttles = EntManager.System<SharedShuttleSystem>();
        _xformSystem = EntManager.System<SharedTransformSystem>();
        MinSize = new Vector2(SizeFull, SizeFull);
    }

    protected override void Draw(DrawingHandleScreen handle)
    {
        base.Draw(handle);

        DrawBacking(handle);

        if (Coordinates == null ||
            Angle == null ||
            DockState == null ||
            !EntManager.TryGetComponent<TransformComponent>(GridEntity, out var gridXform))
        {
            DrawNoSignal(handle);
            return;
        }

        DrawCircles(handle);
        var mapPos = _xformSystem.ToMapCoordinates(Coordinates.Value);
        var ourGridMatrix = _xformSystem.GetWorldMatrix(gridXform.Owner);
        var dockMatrix = Matrix3.CreateTransform(Coordinates.Value.Position, Robust.Shared.Maths.Angle.Zero);
        Matrix3.Multiply(dockMatrix, ourGridMatrix, out var offsetMatrix);

        offsetMatrix = offsetMatrix.Invert();

        // Draw nearby grids
        var boundsEnlargement = (Vector2.One / MinimapScale).Floored();

        var controlBounds = UIBox2i.FromDimensions(PixelPosition - boundsEnlargement, PixelSize + boundsEnlargement);
        _grids.Clear();
        _mapManager.FindGridsIntersecting(gridXform.MapID, new Box2(mapPos.Position - WorldRangeVector, mapPos.Position + WorldRangeVector), ref _grids);

        foreach (var grid in _grids)
        {
            EntManager.TryGetComponent(grid.Owner, out IFFComponent? iffComp);

            if (grid.Owner != GridEntity && !_shuttles.CanDraw(grid.Owner, iffComp: iffComp))
                continue;

            var gridMatrix = _xformSystem.GetWorldMatrix(grid.Owner);
            Matrix3.Multiply(in gridMatrix, in offsetMatrix, out var matty);
            var color = _shuttles.GetIFFColor(grid.Owner, grid.Owner == GridEntity, component: iffComp);

            DrawGrid(handle, matty, grid, color);

            // Draw any docks on that grid
            if (DockState.Docks.TryGetValue(EntManager.GetNetEntity(grid), out var gridDocks))
            {
                foreach (var dock in gridDocks)
                {
                    if (ViewedDock == dock.Entity)
                        continue;

                    var position = matty.Transform(dock.Coordinates.Position);

                    var otherDockRotation = Matrix3.CreateRotation(dock.Angle);
                    var scaledPos = ScalePosition(position with {Y = -position.Y});

                    if (!controlBounds.Contains(scaledPos.Floored()))
                        continue;

                    // Draw the dock's collision
                    var collisionBL = matty.Transform(dock.Coordinates.Position +
                                                      otherDockRotation.Transform(new Vector2(-0.2f, -0.7f)));
                    var collisionBR = matty.Transform(dock.Coordinates.Position +
                                                      otherDockRotation.Transform(new Vector2(0.2f, -0.7f)));
                    var collisionTR = matty.Transform(dock.Coordinates.Position +
                                                      otherDockRotation.Transform(new Vector2(0.2f, -0.5f)));
                    var collisionTL = matty.Transform(dock.Coordinates.Position +
                                                      otherDockRotation.Transform(new Vector2(-0.2f, -0.5f)));

                    var verts = new[]
                    {
                        collisionBL,
                        collisionBR,
                        collisionBR,
                        collisionTR,
                        collisionTR,
                        collisionTL,
                        collisionTL,
                        collisionBL,
                    };

                    for (var i = 0; i < verts.Length; i++)
                    {
                        var vert = verts[i];
                        vert.Y = -vert.Y;
                        verts[i] = ScalePosition(vert);
                    }

                    var otherDockConnection = Color.ToSrgb(Color.Pink);
                    handle.DrawPrimitives(DrawPrimitiveTopology.TriangleFan, verts, otherDockConnection.WithAlpha(0.2f));
                    handle.DrawPrimitives(DrawPrimitiveTopology.LineList, verts, otherDockConnection);

                    // Draw the dock itself
                    var dockBL = matty.Transform(dock.Coordinates.Position + new Vector2(-0.5f, -0.5f));
                    var dockBR = matty.Transform(dock.Coordinates.Position + new Vector2(0.5f, -0.5f));
                    var dockTR = matty.Transform(dock.Coordinates.Position + new Vector2(0.5f, 0.5f));
                    var dockTL = matty.Transform(dock.Coordinates.Position + new Vector2(-0.5f, 0.5f));

                    verts = new[]
                    {
                        dockBL,
                        dockBR,
                        dockBR,
                        dockTR,
                        dockTR,
                        dockTL,
                        dockTL,
                        dockBL
                    };

                    for (var i = 0; i < verts.Length; i++)
                    {
                        var vert = verts[i];
                        vert.Y = -vert.Y;
                        verts[i] = ScalePosition(vert);
                    }

                    Color otherDockColor;

                    if (HighlightedDock == dock.Entity)
                    {
                        otherDockColor = Color.ToSrgb(Color.Magenta);
                    }
                    else
                    {
                       otherDockColor = Color.ToSrgb(Color.Purple);
                    }

                    handle.DrawPrimitives(DrawPrimitiveTopology.TriangleFan, verts, otherDockColor.WithAlpha(0.2f));
                    handle.DrawPrimitives(DrawPrimitiveTopology.LineList, verts, otherDockColor);
                }
            }
        }

        // Draw the dock's collision
        var invertedPosition = Vector2.Zero;
        invertedPosition.Y = -invertedPosition.Y;
        var rotation = Matrix3.CreateRotation(-Angle.Value + MathF.PI);
        var ourDockConnection = new UIBox2(
            ScalePosition(rotation.Transform(new Vector2(-0.2f, -0.7f))),
            ScalePosition(rotation.Transform(new Vector2(0.2f, -0.5f))));

        var ourDock = new UIBox2(
            ScalePosition(rotation.Transform(new Vector2(-0.5f, 0.5f))),
            ScalePosition(rotation.Transform(new Vector2(0.5f, -0.5f))));

        var dockColor = Color.Magenta;
        var connectionColor = Color.Pink;

        handle.DrawRect(ourDockConnection, connectionColor.WithAlpha(0.2f));
        handle.DrawRect(ourDockConnection, connectionColor, filled: false);

        // Draw the dock itself
        handle.DrawRect(ourDock, dockColor.WithAlpha(0.2f));
        handle.DrawRect(ourDock, dockColor, filled: false);

        // TODO: Draw dotted line to nearest other dock, also needs to highlight button
    }
}
