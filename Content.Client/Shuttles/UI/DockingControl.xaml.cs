using System.Numerics;
using Content.Shared.Shuttles.BUIStates;
using Content.Shared.Shuttles.Components;
using Content.Shared.Shuttles.Systems;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Map;
using Robust.Shared.Map.Components;
using Robust.Shared.Physics.Collision.Shapes;

namespace Content.Client.Shuttles.UI;

[GenerateTypedNameReferences]
public sealed partial class DockingControl : BaseShuttleControl
{
    [Dependency] private readonly IMapManager _mapManager = default!;
    private readonly SharedShuttleSystem _shuttles;
    private readonly SharedTransformSystem _xformSystem;

    public NetEntity? ViewedDock;
    public EntityUid? GridEntity;

    public EntityCoordinates? Coordinates;
    public Angle? Angle;

    public DockingInterfaceState? DockState = null;

    private List<Entity<MapGridComponent>> _grids = new();

    public DockingControl() : base(8f, 32f, 8f)
    {
        RobustXamlLoader.Load(this);
        _shuttles = EntManager.System<SharedShuttleSystem>();
        _xformSystem = EntManager.System<SharedTransformSystem>();
        MinSize = new Vector2(SizeFull, SizeFull);
    }

    protected override void Draw(DrawingHandleScreen handle)
    {
        base.Draw(handle);

        DrawBacking(handle);

        if (Coordinates == null ||
            Angle == null ||
            DockState == null ||
            !EntManager.TryGetComponent<TransformComponent>(GridEntity, out var gridXform))
        {
            DrawNoSignal(handle);
            return;
        }

        DrawCircles(handle);
        var (worldPos, worldRot) = _xformSystem.GetWorldPositionRotation(Coordinates.Value.EntityId);
        var gridInvMatrix = _xformSystem.GetInvWorldMatrix(gridXform.Owner);
        var dockMatrix = Matrix3.CreateTranslation(-Coordinates.Value.Position);
        Matrix3.Multiply(gridInvMatrix, dockMatrix, out var offsetMatrix);

        // Draw nearby grids
        var controlBounds = PixelRect;
        _grids.Clear();
        _mapManager.FindGridsIntersecting(gridXform.MapID, new Box2(worldPos - WorldRangeVector, worldPos + WorldRangeVector), ref _grids);

        foreach (var grid in _grids)
        {
            EntManager.TryGetComponent(grid.Owner, out IFFComponent? iffComp);

            if (!_shuttles.CanDraw(grid.Owner, iffComp: iffComp))
                continue;

            var gridMatrix = _xformSystem.GetWorldMatrix(grid.Owner);
            Matrix3.Multiply(in gridMatrix, in offsetMatrix, out var matty);
            var color = _shuttles.GetIFFColor(grid.Owner, grid.Owner == GridEntity, component: iffComp);

            DrawGrid(handle, matty, grid, color);

            // Draw any docks on that grid
            if (DockState.Docks.TryGetValue(EntManager.GetNetEntity(grid), out var gridDocks))
            {
                foreach (var dock in gridDocks)
                {
                    if (ViewedDock == dock.Entity)
                        continue;

                    var position = matty.Transform(dock.Coordinates.Position);

                    var otherDockRotation = Matrix3.CreateRotation(dock.Angle);
                    var scaledPos = ScalePosition(position with {Y = -position.Y});

                    if (!controlBounds.Contains(scaledPos.Floored()))
                        continue;

                    // Draw the dock's collision
                    var verts = new[]
                    {
                        matty.Transform(dock.Coordinates.Position +
                                        otherDockRotation.Transform(new Vector2(-0.2f, -0.7f))),
                        matty.Transform(dock.Coordinates.Position +
                                        otherDockRotation.Transform(new Vector2(0.2f, -0.7f))),
                        matty.Transform(dock.Coordinates.Position +
                                        otherDockRotation.Transform(new Vector2(0.2f, -0.5f))),
                        matty.Transform(dock.Coordinates.Position +
                                        otherDockRotation.Transform(new Vector2(-0.2f, -0.5f))),
                    };

                    for (var i = 0; i < verts.Length; i++)
                    {
                        var vert = verts[i];
                        vert.Y = -vert.Y;
                        verts[i] = ScalePosition(vert);
                    }

                    var otherDockConnection = Color.Turquoise;
                    handle.DrawPrimitives(DrawPrimitiveTopology.TriangleFan, verts, otherDockConnection.WithAlpha(0.05f));
                    handle.DrawPrimitives(DrawPrimitiveTopology.LineList, verts, otherDockConnection);

                    // Draw the dock itself
                    verts = new[]
                    {
                        matty.Transform(dock.Coordinates.Position + new Vector2(-0.5f, -0.5f)),
                        matty.Transform(dock.Coordinates.Position + new Vector2(0.5f, -0.5f)),
                        matty.Transform(dock.Coordinates.Position + new Vector2(0.5f, 0.5f)),
                        matty.Transform(dock.Coordinates.Position + new Vector2(-0.5f, 0.5f)),
                    };

                    for (var i = 0; i < verts.Length; i++)
                    {
                        var vert = verts[i];
                        vert.Y = -vert.Y;
                        verts[i] = ScalePosition(vert);
                    }

                    var otherDockColor = Color.Purple;
                    handle.DrawPrimitives(DrawPrimitiveTopology.TriangleFan, verts, otherDockColor.WithAlpha(0.2f));
                    handle.DrawPrimitives(DrawPrimitiveTopology.LineList, verts, otherDockColor);
                }
            }
        }

        // Draw the dock's collision
        var invertedPosition = Vector2.Zero;
        invertedPosition.Y = -invertedPosition.Y;
        var rotation = Matrix3.CreateRotation(-Angle.Value + MathF.PI);
        var ourDockConnection = new UIBox2(
            ScalePosition(rotation.Transform(new Vector2(-0.2f, -0.7f))),
            ScalePosition(rotation.Transform(new Vector2(0.2f, -0.5f))));

        var ourDock = new UIBox2(
            ScalePosition(rotation.Transform(new Vector2(-0.5f, 0.5f))),
            ScalePosition(rotation.Transform(new Vector2(0.5f, -0.5f))));

        var dockColor = Color.Purple;
        var connectionColor = Color.Pink;

        handle.DrawRect(ourDockConnection, connectionColor.WithAlpha(0.2f));
        handle.DrawRect(ourDockConnection, connectionColor, filled: false);

        // Draw the dock itself
        handle.DrawRect(ourDock, dockColor.WithAlpha(0.2f));
        handle.DrawRect(ourDock, dockColor, filled: false);

        // TODO: Draw dotted line to nearest other dock, also needs to highlight button 
    }
}
