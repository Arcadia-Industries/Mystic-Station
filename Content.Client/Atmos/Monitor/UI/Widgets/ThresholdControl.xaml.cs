using System;
using Content.Shared.Atmos;
using Content.Shared.Atmos.Monitor;
using Content.Shared.Atmos.Monitor.Components;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.CustomControls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Localization;

// holy FUCK
// this technically works because some of this you can *not* do in XAML but holy FUCK

namespace Content.Client.Atmos.Monitor.UI.Widgets;

[GenerateTypedNameReferences]
public sealed partial class ThresholdControl : BoxContainer
{
    private AtmosAlarmThreshold _threshold;
    private AtmosMonitorThresholdType _type;
    private Gas? _gas;

    public event Action<AtmosMonitorThresholdType, AtmosAlarmThreshold, Gas?>? ThresholdDataChanged;

    private CollapsibleHeading _name => CName;
    private CheckBox _enabled => CEnabled;
    private BoxContainer _dangerBounds => CDangerBounds;
    private BoxContainer _warningBounds => CWarningBounds;
    private ThresholdBoundControl _upperBoundControl;
    private ThresholdBoundControl _lowerBoundControl;
    private ThresholdBoundControl _upperWarningBoundControl;
    private ThresholdBoundControl _lowerWarningBoundControl;

    // i have played myself by making threshold values nullable to
    // indicate validity/disabled status, with several layers of side effect
    // dependent on the other three values when you change one :HECK:
    public ThresholdControl(string name, AtmosAlarmThreshold threshold, AtmosMonitorThresholdType type, Gas? gas = null, float modifier = 1)
    {
        RobustXamlLoader.Load(this);

        _threshold = threshold;
        _type = type;
        _gas = gas;

        _name.Title = name;

        // i miss rust macros

        _upperBoundControl = new ThresholdBoundControl(LabelForBound("upper-bound"), _threshold.UpperBound.Value, modifier);
        _upperBoundControl.OnBoundChanged += value =>
        {
            // a lot of threshold logic is baked into the properties,
            // so setting this just returns if a change occurred or not
            _threshold.TrySetPrimaryBound(AtmosMonitorThresholdBound.Upper, value);
            return _threshold.UpperBound.Value;
        };
        _upperBoundControl.OnBoundEnabled += () =>
        {
            var value = 0f;

            if (_threshold.LowerWarningBound.Enabled)
                value = (float) _threshold.LowerWarningBound.Value + 0.1f;
            else if (_threshold.LowerBound.Enabled)
                value = (float) _threshold.LowerBound.Value + 0.1f;

            return value;
        };
        _upperBoundControl.OnValidBoundChanged += () =>
        {
            ThresholdDataChanged!.Invoke(_type, _threshold, _gas);
        };
        _dangerBounds.AddChild(_upperBoundControl);

        _lowerBoundControl = new ThresholdBoundControl(LabelForBound("lower-bound"), _threshold.LowerBound.Value, modifier);
        _lowerBoundControl.OnBoundChanged += value =>
        {
            _threshold.TrySetPrimaryBound(AtmosMonitorThresholdBound.Lower, value);
            return _threshold.LowerBound.Value;
        };
        _lowerBoundControl.OnBoundEnabled += () =>
        {
            var value = 0f;

            if (_threshold.UpperWarningBound.Enabled)
                value = (float) _threshold.UpperWarningBound.Value - 0.1f;
            else if (_threshold.UpperBound.Enabled)
                value = (float) _threshold.UpperBound.Value - 0.1f;

            return value;
        };
        _lowerBoundControl.OnValidBoundChanged += () =>
            ThresholdDataChanged!.Invoke(_type, _threshold, _gas);
        _dangerBounds.AddChild(_lowerBoundControl);

        _upperWarningBoundControl = new ThresholdBoundControl(LabelForBound("upper-warning-bound"), _threshold.UpperWarningBound.Value, modifier);
        _upperWarningBoundControl.OnBoundChanged += value =>
        {
            _threshold.TrySetWarningBound(AtmosMonitorThresholdBound.Upper, value);
            return _threshold.UpperWarningBound.Value;
        };
        _upperWarningBoundControl.OnBoundEnabled += () =>
        {
            var value = 0f;

            if (_threshold.LowerWarningBound.Enabled)
                value = (float) _threshold.LowerWarningBound.Value + 0.1f;
            else if (_threshold.LowerBound.Enabled)
                value = (float) _threshold.LowerBound.Value + 0.1f;

            return value;
        };
        _upperWarningBoundControl.OnValidBoundChanged += () =>
            ThresholdDataChanged!.Invoke(_type, _threshold, _gas);
        _warningBounds.AddChild(_upperWarningBoundControl);

        _lowerWarningBoundControl = new ThresholdBoundControl(LabelForBound("lower-warning-bound"), _threshold.LowerWarningBound.Value, modifier);
        _lowerWarningBoundControl.OnBoundChanged += value =>
        {
            _threshold.TrySetWarningBound(AtmosMonitorThresholdBound.Lower, value);
            return _threshold.LowerWarningBound.Value;
        };
        _lowerWarningBoundControl.OnBoundEnabled += () =>
        {
            var value = 0f;

            if (_threshold.UpperWarningBound.Enabled)
                value = (float) _threshold.UpperWarningBound.Value - 0.1f;
            else if (_threshold.UpperBound.Enabled)
                value = (float) _threshold.UpperBound.Value - 0.1f;

            return value;
        };
        _lowerWarningBoundControl.OnValidBoundChanged += () =>
            ThresholdDataChanged!.Invoke(_type, _threshold, _gas);

        _warningBounds.AddChild(_lowerWarningBoundControl);

        _enabled.OnToggled += args =>
        {
            _threshold.Ignore = !args.Pressed;
            ThresholdDataChanged!.Invoke(_type, _threshold, _gas);
        };
        _enabled.Pressed = !_threshold.Ignore;
    }

    public void UpdateThresholdData(AtmosAlarmThreshold threshold)
    {
        _upperBoundControl.SetValue(threshold.UpperBound.Value);
        _lowerBoundControl.SetValue(threshold.LowerBound.Value);
        _upperWarningBoundControl.SetValue(threshold.UpperWarningBound.Value);
        _lowerWarningBoundControl.SetValue(threshold.LowerWarningBound.Value);
        _enabled.Pressed = !threshold.Ignore;
    }

    private String LabelForBound(string boundType) //<todo.eoin Replace this with enums
    {
        return Loc.GetString($"air-alarm-ui-thresholds-{boundType}");
    }
}
