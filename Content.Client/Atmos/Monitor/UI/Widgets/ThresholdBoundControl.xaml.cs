using Content.Client.Message;
using Content.Shared.Atmos;
using Content.Shared.Atmos.Monitor;
using Content.Shared.Temperature;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;

namespace Content.Client.Atmos.Monitor.UI.Widgets;

[GenerateTypedNameReferences]
public sealed partial class ThresholdBoundControl : BoxContainer
{
    // raw values to use in thresholds, prefer these
    // over directly setting Modified(Value/LastValue)
    // when working with the FloatSpinBox
    private float? _value;
    private float _lastValue;

    // convenience thing for getting multiplied values
    // and also setting value to a usable value
    private float? ModifiedValue
    {
        get => _value * _modifier;
        set => _value = value / _modifier;
    }

    private float ModifiedLastValue
    {
        get => _lastValue * _modifier;
        set => _lastValue = value / _modifier;
    }

    private float _modifier;

    public event Action? OnValidBoundChanged;
    public Func<float?, float?>? OnBoundChanged;
    public Func<float>? OnBoundEnabled;

    public void SetValue(float? value)
    {
        _value = value;

        if (_value == null)
        {
            CBoundEnabled.Pressed = false;
            CSpinner.Value = 0;
        }
        else
        {
            CBoundEnabled.Pressed = true;
            CSpinner.Value = (float) ModifiedValue!;
        }
    }

    public ThresholdBoundControl(string controlLabel, float? value, float modifier = 1)
    {
        RobustXamlLoader.Load(this);

        _modifier = modifier > 0 ? modifier : 1;
        _value = value;

        CBoundLabel.Text = controlLabel;

        CSpinner.Value = ModifiedValue ?? 2;
        _lastValue = _value ?? 0;
        CBoundEnabled.Pressed = _value != null;

        CSpinner.OnValueChanged += ChangeValue;
        CSpinner.IsValid += ValidateThreshold;
        CBoundEnabled.OnToggled += ToggleBound;
    }

    private void ChangeValue(FloatSpinBox.FloatSpinBoxEventArgs args)
    {
        // ensure that the value in the spinbox is transformed
        ModifiedValue = args.Value;
        // set the value in the scope above
        var value = OnBoundChanged!(_value);
        // is the value not null, or has it changed?
        if (value != null || value != _lastValue)
        {
            _value = value;
            _lastValue = (float) value!;
            OnValidBoundChanged!.Invoke();
        }
        // otherwise, just set it to the last known value
        else
        {
            _value = _lastValue;
            CSpinner.Value = ModifiedLastValue;
        }
    }

    private void ToggleBound(BaseButton.ButtonToggledEventArgs args)
    {
        if (args.Pressed)
        {
            var value = OnBoundChanged!(_lastValue);

            if (value != _lastValue)
            {
                value = OnBoundChanged!(OnBoundEnabled!());

                if (value == null || value < 0)
                {
                    // TODO: Improve UX here, this is ass
                    // basically this implies that the bound
                    // you currently have is too aggressive
                    // for the other set of values, so a
                    // default value (which is +/-0.1) can't
                    // be used
                    CBoundEnabled.Pressed = false;
                    return;
                }
            }

            _value = value;

            CSpinner.Value = (float) ModifiedValue!;
            _lastValue = (float) _value;
        }
        else
        {
            _value = null;
            CSpinner.Value = 0f;
            OnBoundChanged!(_value);
        }

        OnValidBoundChanged!.Invoke();
    }

    private bool ValidateThreshold(float value)
    {
        return _value != null && value >= 0;
    }

}
