using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Random;

namespace Content.Client.Paper.UI
{
    [GenerateTypedNameReferences]
    public sealed partial class StampCollection : Container
    {
        private List<StampWidget> _stamps = new();

        public int PlacementSeed;

        public StampCollection()
        {
            RobustXamlLoader.Load(this);
        }

        /*
        protected override void Draw(DrawingHandleScreen handle)
        {
            base.Draw(handle);
            handle.DrawRect(PixelSizeBox, Color.Orange);
            var r = (PixelSizeBox.Size * 0.5f).Length;
            var dtheta = -MathHelper.DegreesToRadians(120);
            var thisCenter = PixelSizeBox.TopLeft + PixelSizeBox.Size * 0.5f;

            var random = new Random(1234); //todo.eoin Entity ID
            for (var i = 0; i < _stamps.Count; i++)
            {
                var stampOrientation = MathHelper.DegreesToRadians((random.NextFloat() - 0.5f) * 10.0f) ;
                _stamps[i].Orientation = stampOrientation;

                var theta = dtheta * i;
                var childCenterOnCircle = thisCenter + new Vector2(MathF.Cos(theta), MathF.Sin(theta)) * r;
                var childHeLocal = _stamps[i].DesiredPixelSize * 0.5f;
                var childHeInThis = new Vector2(childHeLocal.X * MathF.Cos(stampOrientation) + childHeLocal.Y * MathF.Sin(stampOrientation),
                        childHeLocal.Y * MathF.Cos(stampOrientation) + childHeLocal.X * MathF.Sin(stampOrientation));
                var clampedCenter = Clamp(Shrink(PixelSizeBox, childHeInThis), childCenterOnCircle);
                handle.DrawCircle(clampedCenter, 10, Color.Green);
             }
        }
        */

        public void RemoveStamps()
        {
            _stamps.Clear();
        }

        public void AddStamp(StampWidget s)
        {
            _stamps.Add(s);
            AddChild(s);
        }

        protected override Vector2 ArrangeOverride(Vector2 finalSize)
        {
            var random = new Random(PlacementSeed);
            var r = (PixelSizeBox.Size * 0.5f).Length;
            var dtheta = -MathHelper.DegreesToRadians(90);
            var thisCenter = PixelSizeBox.TopLeft + PixelSizeBox.Size * 0.5f;

            for (var i = 0; i < _stamps.Count; i++)
            {
                var stampOrientation = MathHelper.DegreesToRadians((random.NextFloat() - 0.5f) * 10.0f) ;
                _stamps[i].Orientation = stampOrientation;

                var theta = dtheta * 0.5f + dtheta * i + (i > 4 ? MathF.Log(1 + i / 4) * dtheta : 0); //<tood.eoin Better layout
                var childCenterOnCircle = thisCenter;
                if (i > 0)
                {
                    // First stamp can go in the center. Subsequent stamps have to find space.
                    childCenterOnCircle += new Vector2(MathF.Cos(theta), MathF.Sin(theta)) * r;
                }

                var childHeLocal = _stamps[i].DesiredPixelSize * 0.5f;
                var clampedCenter = Clamp(Shrink(PixelSizeBox, childHeLocal), childCenterOnCircle); //<tood.eoin Should shrink by rotated HE
                var realPosition = clampedCenter - childHeLocal;
                _stamps[i].ArrangePixel(new UIBox2i(ToI(realPosition), ToI(realPosition) + _stamps[i].DesiredPixelSize));
            }

            return finalSize; //<todo.eoin Recalc real bounds
        }

        private Vector2i ToI(Vector2 v)
        {
            return new Vector2i((int)v.X, (int)v.Y);
        }

        private UIBox2 Shrink(UIBox2 box, Vector2 shrinkHe)
        {
            return new UIBox2(box.TopLeft + shrinkHe, box.BottomRight - shrinkHe);
        }

        private Vector2 Clamp(UIBox2 box, Vector2 point)
        {
            return Vector2.ComponentMin(box.BottomRight, Vector2.ComponentMax(box.TopLeft, point));
        }
    }
}
