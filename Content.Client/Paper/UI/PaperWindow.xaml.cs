using Content.Shared.Paper;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.ResourceManagement;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.CustomControls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Utility;

namespace Content.Client.Paper.UI
{
    [GenerateTypedNameReferences]
    public sealed partial class PaperWindow : DefaultWindow
    {
        // We keep a reference to the paper content texture that we create
        // so that we can modify it later.
        private StyleBoxTexture _paperContentTex = new();

        public PaperWindow()
        {
            RobustXamlLoader.Load(this);

            // We can't configure the RichTextLabel contents from xaml, so do it here:
            BlankPaperIndicator.SetMessage(Loc.GetString("paper-ui-blank-page-message"));
        }

        public void InitVisuals(PaperVisualsComponent visuals)
        {
            var resCache = IoCManager.Resolve<IResourceCache>();

            /// Initialize the background:

            //<todo.eoin there is surely sugar for this?
            PaperBackground.ModulateSelfOverride = visuals.BackgroundModulate;
            var backgroundImage = visuals.BackgroundImagePath != null? resCache.GetResource<TextureResource>(visuals.BackgroundImagePath) : null;
            if (backgroundImage != null)
            {
                var backgroundImageMode = visuals.BackgroundImageTile ? StyleBoxTexture.StretchMode.Tile : StyleBoxTexture.StretchMode.Stretch;
                var backgroundPatchMargin = visuals.BackgroundPatchMargin;
                PaperBackground.PanelOverride = new StyleBoxTexture
                {
                    Texture = backgroundImage,
                    TextureScale = visuals.BackgroundScale,
                    Mode = backgroundImageMode,
                    PatchMarginLeft = backgroundPatchMargin.Left,
                    PatchMarginBottom = backgroundPatchMargin.Bottom,
                    PatchMarginRight = backgroundPatchMargin.Right,
                    PatchMarginTop = backgroundPatchMargin.Top
                };

            }
            else
            {
                PaperBackground.PanelOverride = null;
            }


            // Then the header:
            if (visuals.HeaderImagePath != null)
            {
                ImageHeader.TexturePath = visuals.HeaderImagePath;
                ImageHeader.MinSize = ImageHeader.TextureNormal?.Size ?? Vector2.Zero;
            }

            ImageHeader.ModulateSelfOverride = visuals.HeaderImageModulate;
            ImageHeader.Margin = new Thickness(visuals.HeaderMargin.Left, visuals.HeaderMargin.Top,
                    visuals.HeaderMargin.Right, visuals.HeaderMargin.Bottom);


            PaperContent.ModulateSelfOverride = visuals.ContentImageModulate;
            WrittenTextLabel.ModulateSelfOverride = visuals.FontAccentColor;

            var contentImage = visuals.ContentImagePath != null ? resCache.GetResource<TextureResource>(visuals.ContentImagePath) : null;
            if (contentImage != null)
            {
                // Setup the paper content texture, but keep a reference to it, as we can't set
                // some font-related properties here. We'll fix those up later, in Draw()
                _paperContentTex = new StyleBoxTexture
                {
                    Texture = contentImage,
                    Mode = StyleBoxTexture.StretchMode.Tile,
                };
                PaperContent.PanelOverride = _paperContentTex;
            }

            PaperContent.Margin = new Thickness(
                    visuals.ContentMargin.Left, visuals.ContentMargin.Top,
                    visuals.ContentMargin.Right, visuals.ContentMargin.Bottom);

            if (visuals.MaxWritableArea != null)
            {
                // Paper has requested that this has a maximum area that you can write on.
                // So, we'll make the window non-resizable and fix the size of the content.
                Resizable = false;
                PaperContent.MinSize = Vector2.Zero;
                PaperContent.MinSize = (Vector2)(visuals.MaxWritableArea);
                PaperContent.MaxSize = (Vector2)(visuals.MaxWritableArea);
            }
       }

        protected override void Draw(DrawingHandleScreen handle)
        {
            // Now do the deferred setup of the written area. At the point
            // that InitVisuals runs, the label hasn't had it's style initialized
            // so we need to get some info out now:
            if (WrittenTextLabel.TryGetStyleProperty<Font>("font", out var font))
            {
                float fontLineHeight = font.GetLineHeight(UIScale);
                // This positions the texture so the font baseline is on the bottom:
                _paperContentTex.ExpandMarginTop = font.GetDescent(UIScale);
                // And this scales the texture so that it's a single text line:
                _paperContentTex.TextureScale = new Vector2(1, fontLineHeight / _paperContentTex.Texture?.Height ?? fontLineHeight);
            }

            base.Draw(handle);
        }

        public void Populate(SharedPaperComponent.PaperBoundUserInterfaceState state)
        {
            bool isEditing = state.Mode == SharedPaperComponent.PaperAction.Write;
            InputContainer.Visible = isEditing;

            var msg = new FormattedMessage();
            // Remove any newlines from the end of the message. There can be a trailing
            // new line at the end of user input, and we would like to display the input
            // box immediately on the next line.
            msg.AddMarkupPermissive(state.Text.TrimEnd('\r', '\n'));
            WrittenTextLabel.SetMessage(msg);
            WrittenTextLabel.Visible = state.Text.Length > 0;

            BlankPaperIndicator.Visible = !isEditing && state.Text.Length == 0;

            StampDisplay.RemoveAllChildren();
            foreach(var stamper in state.StampedBy)
            {
                StampDisplay.AddChild(new StampWidget{ Stamper = stamper });
            }

            // The DefaultWindow sets an arbitrary MinSize. We'll set this back so that
            // the min size is enough to contain the content without overlapping.
            MinSize = DesiredSize;
        }
    }
}
