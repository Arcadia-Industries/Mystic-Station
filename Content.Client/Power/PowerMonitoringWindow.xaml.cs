using Content.Client.Pinpointer.UI;
using Content.Client.Stylesheets;
using Content.Client.UserInterface.Controls;
using Content.Shared.Pinpointer;
using Content.Shared.Power;
using Robust.Client.AutoGenerated;
using Robust.Client.GameObjects;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Client.Utility;
using Robust.Shared.Map;
using Robust.Shared.Map.Components;
using Robust.Shared.Timing;
using Robust.Shared.Utility;
using System.Linq;
using System.Numerics;

namespace Content.Client.Power;

[GenerateTypedNameReferences]
public sealed partial class PowerMonitoringWindow : FancyWindow
{
    private readonly IEntityManager _entManager;
    private readonly SpriteSystem _spriteSystem;

    private float _updateTimer = 1.0f;
    private const float UpdateTime = 1.0f;

    private EntityUid? _trackedEntity;
    private float? _nextScrollValue;

    public event Action<NetEntity?>? RequestPowerMonitoringDataAction;

    private List<CableData> _networkColors = new List<CableData>()
    {
        new CableData(CableType.HighVoltage, Color.Orange),
        new CableData(CableType.MediumVoltage, Color.Yellow, new Vector2(-0.2f, -0.2f)),
        new CableData(CableType.Apc, Color.LimeGreen, new Vector2(0.2f, 0.2f)),
    };

    private List<CableData> _darkNetworkData = new List<CableData>()
    {
        new CableData(CableType.HighVoltage, new Color(82,52,0)),
        new CableData(CableType.MediumVoltage, new Color(80,80,0), new Vector2(-0.2f, -0.2f)),
        new CableData(CableType.Apc, new Color(20,76,20), new Vector2(0.2f, 0.2f)),
    };

    public PowerMonitoringWindow(PowerMonitoringConsoleBoundUserInterface userInterface, EntityUid? mapUid)
    {
        RobustXamlLoader.Load(this);
        _entManager = IoCManager.Resolve<IEntityManager>();
        _spriteSystem = IoCManager.Resolve<SpriteSystem>();

        // Get grid uid
        if (_entManager.TryGetComponent<TransformComponent>(mapUid, out var xform))
            NavMap.MapUid = xform.GridUid;

        else
            NavMap.Visible = false;

        // Set UI tab titles
        MasterTabContainer.SetTabTitle(0, Loc.GetString("power-monitoring-window-label-sources"));
        MasterTabContainer.SetTabTitle(1, Loc.GetString("power-monitoring-window-label-smes"));
        MasterTabContainer.SetTabTitle(2, Loc.GetString("power-monitoring-window-label-substation"));
        MasterTabContainer.SetTabTitle(3, Loc.GetString("power-monitoring-window-label-apc"));

        // Set UI toggles
        ShowHVCable.OnToggled += _ => OnShowCableToggled(ShowHVCable, CableType.HighVoltage);
        ShowMVCable.OnToggled += _ => OnShowCableToggled(ShowMVCable, CableType.MediumVoltage);
        ShowLVCable.OnToggled += _ => OnShowCableToggled(ShowLVCable, CableType.Apc);

        NavMap.ShowCables = new Dictionary<CableType, bool>
        {
            [CableType.HighVoltage] = true,
            [CableType.MediumVoltage] = true,
            [CableType.Apc] = true,
        };

        // Turn off beacons (they obscure too much)
        NavMap.ShowBeacons = false;

        // Set power monitoring data request action
        RequestPowerMonitoringDataAction += userInterface.RequestPowerMonitoringData;
    }

    private void OnShowCableToggled(CheckBox checkBox, CableType cableType)
    {
        NavMap.ShowCables[cableType] = !NavMap.ShowCables[cableType];
    }

    public void ShowEntites
        (float totalSources,
        float totalLoads,
        PowerMonitoringConsoleEntry[] allSources,
        PowerMonitoringConsoleEntry[] allLoads,
        PowerMonitoringConsoleEntry[] focusSources,
        PowerMonitoringConsoleEntry[] focusLoads,
        Dictionary<Vector2i, NavMapChunkPowerCables> powerCableChunks,
        Dictionary<Vector2i, NavMapChunkPowerCables>? focusCableChunks,
        EntityCoordinates? monitorCoords)
    {
        if (!_entManager.TryGetComponent<MapGridComponent>(NavMap.MapUid, out var grid))
            return;

        if (!_entManager.TryGetComponent<NavMapComponent>(NavMap.MapUid, out var navMap))
            return;

        // Reset nav map values
        NavMap.TrackedCoordinates.Clear();
        NavMap.TrackedEntities.Clear();
        NavMap.FocusCableNetwork = null;

        // Update nav map tile grid
        NavMap.TileGrid = DecodeTileChunks(navMap.Chunks, grid);

        // Update nav map power cable networks
        if (focusCableChunks != null && focusCableChunks.Any())
        {
            NavMap.PowerCableNetwork = DecodePowerCableChunks(powerCableChunks, _darkNetworkData, grid);
            NavMap.FocusCableNetwork = DecodePowerCableChunks(focusCableChunks, _networkColors, grid);
        }

        else
        {
            NavMap.PowerCableNetwork = DecodePowerCableChunks(powerCableChunks, _networkColors, grid);
        }

        // Draw all sources on the map
        bool useDarkColors = focusSources.Any() || focusLoads.Any();

        foreach (var source in allSources)
        {
            if (source.Coordinates == null)
                continue;

            AddTrackedEntityToNavMap(_entManager.GetEntity(source.NetEntity), _entManager.GetCoordinates(source.Coordinates.Value), source, useDarkColors);
        }

        foreach (var load in allLoads)
        {
            if (load.Coordinates == null)
                continue;

            AddTrackedEntityToNavMap(_entManager.GetEntity(load.NetEntity), _entManager.GetCoordinates(load.Coordinates.Value), load, useDarkColors);
        }

        foreach (var source in focusSources)
        {
            if (source.Coordinates == null)
                continue;

            AddTrackedEntityToNavMap(_entManager.GetEntity(source.NetEntity), _entManager.GetCoordinates(source.Coordinates.Value), source);
        }

        foreach (var load in focusLoads)
        {
            if (load.Coordinates == null)
                continue;

            AddTrackedEntityToNavMap(_entManager.GetEntity(load.NetEntity), _entManager.GetCoordinates(load.Coordinates.Value), load);
        }

        // Show monitor location
        var monitor = _spriteSystem.Frame0(new SpriteSpecifier.Texture(new(PowerMonitoringHelper.CircleIconPath)));

        if (monitorCoords != null)
            NavMap.TrackedEntities.Add(monitorCoords.Value, (true, Color.Cyan, monitor));

        // Update power status text
        TotalSources.Text = Loc.GetString("power-monitoring-window-value", ("value", totalSources));
        TotalLoads.Text = Loc.GetString("power-monitoring-window-value", ("value", totalLoads));
        TotalLoads.FontColorOverride = totalSources < totalLoads && !MathHelper.CloseToPercent(totalSources, totalLoads, 0.1f) ? new Color(180, 0, 0) : Color.White;

        // Update generator list
        UpdatePowerMonitoringConsoleEntries(SourcesList, allSources, null, focusLoads);

        // Update SMES list
        var smesList = allLoads.Where(x => x.Group == PowerMonitoringConsoleGroup.SMES);
        UpdatePowerMonitoringConsoleEntries(SMESList, smesList.ToArray(), focusSources, focusLoads);

        // Update substation list
        var substationList = allLoads.Where(x => x.Group == PowerMonitoringConsoleGroup.Substation);
        UpdatePowerMonitoringConsoleEntries(SubstationList, substationList.ToArray(), focusSources, focusLoads);

        // Update APC list
        var apcList = allLoads.Where(x => x.Group == PowerMonitoringConsoleGroup.APC);
        UpdatePowerMonitoringConsoleEntries(ApcList, apcList.ToArray(), focusSources, null);
    }

    private void AddTrackedEntityToNavMap(EntityUid uid, EntityCoordinates coords, PowerMonitoringConsoleEntry entry, bool useDarkColors = false)
    {
        if (!NavMap.Visible)
            return;

        var color = useDarkColors ? new Color(54, 0, 54) : Color.Purple;
        var icon = _spriteSystem.Frame0(new SpriteSpecifier.Texture(new(PowerMonitoringHelper.CircleIconPath)));

        if (entry.Group == PowerMonitoringConsoleGroup.SMES)
        {
            color = useDarkColors ? new Color(82, 52, 0) : Color.Orange;
            icon = _spriteSystem.Frame0(new SpriteSpecifier.Texture(new(PowerMonitoringHelper.TriangleIconPath)));
        }

        else if (entry.Group == PowerMonitoringConsoleGroup.Substation)
        {
            color = useDarkColors ? new Color(80, 80, 0) : Color.Yellow;
            icon = _spriteSystem.Frame0(new SpriteSpecifier.Texture(new(PowerMonitoringHelper.TriangleIconPath)));
        }

        else if (entry.Group == PowerMonitoringConsoleGroup.APC)
        {
            color = useDarkColors ? new Color(20, 76, 20) : Color.LimeGreen;
            icon = _spriteSystem.Frame0(new SpriteSpecifier.Texture(new(PowerMonitoringHelper.TriangleIconPath)));
        }

        // Set to white if currently the focus
        color = uid == _trackedEntity ? Color.White : color;

        NavMap.TrackedEntities.TryAdd(coords, (true, color, icon));
    }

    protected override void FrameUpdate(FrameEventArgs args)
    {
        if (_nextScrollValue != null)
        {
            var scroll = MasterTabContainer.Children.ElementAt(MasterTabContainer.CurrentTab) as ScrollContainer;
            if (scroll == null)
                return;

            scroll.SetScrollValue(new Vector2(0, _nextScrollValue.Value));

            _nextScrollValue = null;
        }

        _updateTimer += args.DeltaSeconds;

        if (_updateTimer >= UpdateTime)
        {
            _updateTimer -= UpdateTime;
            RequestPowerMonitoringDataAction?.Invoke(_entManager.GetNetEntity(_trackedEntity));
        }
    }

    public void UpdateEntry(PowerMonitoringButton child, PowerMonitoringConsoleEntry entry, float offset = 38f)
    {
        var uid = _entManager.GetEntity(entry.NetEntity);
        child.EntityUid = uid;
        child.HorizontalExpand = true;
        //child.SetHeight = 40;

        if (uid == _trackedEntity)
        {
            child.AddStyleClass(StyleNano.StyleClassButtonColorGreen);
        }

        else
        {
            child.RemoveStyleClass(StyleNano.StyleClassButtonColorGreen);
        }

        child.ToolTip = Loc.GetString(entry.NameLocalized);

        if (child.Grid == null)
        {
            child.Grid = new GridContainer
            {
                Columns = 3,
            };

            child.AddChild(child.Grid);
        }

        if (child.SpriteView == null)
        {
            child.SpriteView = new SpriteView();
            child.Grid.AddChild(child.SpriteView);
        }

        child.SpriteView.SetEntity(uid);
        child.SpriteView.OverrideDirection = Direction.South;
        child.SpriteView.SetSize = new Vector2(32f, 32f);

        if (child.Name == null)
        {
            child.Name = new Label();
            child.Grid.AddChild(child.Name);
        }

        child.Name.MinWidth = 220f + offset;
        child.Name.MaxWidth = 220f + offset;
        child.Name.ClipText = true;

        var name = Loc.GetString(entry.NameLocalized);
        var _charLimit = (int) (child.Name.MaxWidth / 8f);
        if (name.Length > _charLimit)
            name = $"{name.Substring(0, _charLimit - 3)}...";

        child.Name.Text = name;

        if (child.Value == null)
        {
            child.Value = new Label();
            child.Grid.AddChild(child.Value);
        }

        child.Value.Text = Loc.GetString("power-monitoring-window-value", ("value", entry.PowerValue));
        child.Value.MinWidth = 64f;
    }

    private void ButtonAction(PowerMonitoringButton child, PowerMonitoringConsoleEntry entry, GridContainer list)
    {
        if (child.EntityUid == _trackedEntity)
        {
            child.RemoveStyleClass(StyleNano.StyleClassButtonColorGreen);
            _trackedEntity = null;

            return;
        }

        child.AddStyleClass(StyleNano.StyleClassButtonColorGreen);

        if (entry.Coordinates != null)
            NavMap.CenterToCoordinates(_entManager.GetCoordinates(entry.Coordinates.Value));

        if (_trackedEntity != null)
        {
            foreach (PowerMonitoringEntry sibling in list.Children)
            {
                if (sibling.Button != null && sibling.Button.EntityUid == _trackedEntity)
                {
                    sibling.RemoveStyleClass(StyleNano.StyleClassButtonColorGreen);
                    break;
                }
            }
        }

        _trackedEntity = child.EntityUid;
        RequestPowerMonitoringDataAction?.Invoke(_entManager.GetNetEntity(_trackedEntity));
        _updateTimer = 0f;

        switch (entry.Group)
        {
            case PowerMonitoringConsoleGroup.Generator:
                MasterTabContainer.CurrentTab = 0; break;
            case PowerMonitoringConsoleGroup.SMES:
                MasterTabContainer.CurrentTab = 1; break;
            case PowerMonitoringConsoleGroup.Substation:
                MasterTabContainer.CurrentTab = 2; break;
            case PowerMonitoringConsoleGroup.APC:
                MasterTabContainer.CurrentTab = 3; break;
        }

        var scroll = MasterTabContainer.Children.ElementAt(MasterTabContainer.CurrentTab) as ScrollContainer;
        if (scroll == null)
            return;

        var grid = scroll.Children.ElementAt(0) as GridContainer;
        if (grid == null)
            return;

        var pos = grid.Children.FirstOrDefault(x => (x is PowerMonitoringEntry) && ((PowerMonitoringEntry) x).EntityUid == _trackedEntity);
        if (pos == null)
            return;

        _nextScrollValue = 40f * pos.GetPositionInParent();
    }

    private void UpdatePowerMonitoringConsoleEntries(GridContainer list, PowerMonitoringConsoleEntry[] listVal, PowerMonitoringConsoleEntry[]? sources, PowerMonitoringConsoleEntry[]? loads)
    {
        // Remove excess children
        while (list.ChildCount > listVal.Length)
        {
            list.RemoveChild(list.GetChild(list.ChildCount - 1));
        }

        if (!listVal.Any())
            return;

        // Add missing children
        while (list.ChildCount < listVal.Length)
        {
            var child = new PowerMonitoringEntry();
            child.Orientation = BoxContainer.LayoutOrientation.Vertical;
            child.HorizontalExpand = true;
            list.AddChild(child);

            var ent = _entManager.GetEntity(listVal.ElementAt(child.GetPositionInParent()).NetEntity);
            child.EntityUid = ent;

            var button = new PowerMonitoringButton();
            button.StyleClasses.Add("OpenLeft");
            child.Button = button;
            child.AddChild(button);

            button.OnButtonUp += args =>
            {
                ButtonAction(button, listVal.ElementAt(child.GetPositionInParent()), list);
            };

            var grid = new GridContainer();
            grid.Columns = 1;
            grid.HorizontalExpand = true;
            grid.Margin = new Thickness(8, 5, 0, 0);
            grid.Visible = false;
            child.MainGrid = grid;
            child.AddChild(grid);

            var subgridSources = new GridContainer();
            subgridSources.Columns = 1;
            subgridSources.HorizontalExpand = true;
            subgridSources.Margin = new Thickness(0, 0, 0, 0);
            child.Sources = subgridSources;
            grid.AddChild(subgridSources);

            var subgridLoads = new GridContainer();
            subgridLoads.Columns = 1;
            subgridLoads.HorizontalExpand = true;
            subgridLoads.Margin = new Thickness(0, 0, 0, 0);
            child.Loads = subgridLoads;
            grid.AddChild(subgridLoads);

            var spacer = new Control();
            spacer.Margin = new Thickness(0, 0, 0, 5);
        }

        foreach (var child in list.Children)
        {
            if (child is not PowerMonitoringEntry)
                continue;

            var castChild = (PowerMonitoringEntry) child;
            if (castChild == null)
                continue;
            if (castChild.Button == null)
                continue;

            var entry = listVal.ElementAt(child.GetPositionInParent());
            var ent = _entManager.GetEntity(entry.NetEntity);

            UpdateEntry(castChild.Button, listVal.ElementAt(child.GetPositionInParent()));

            if (castChild.MainGrid == null)
                continue;

            if (_trackedEntity == ent)
            {
                castChild.MainGrid.Visible = true;
                UpdateEntrySourcesLoads(castChild.Sources, sources);
                UpdateEntrySourcesLoads(castChild.Loads, loads, false);
            }

            else
                castChild.MainGrid.Visible = false;
        }
    }

    private void UpdateEntrySourcesLoads(GridContainer? list, PowerMonitoringConsoleEntry[]? listVal, bool isSource = true)
    {
        if (list == null)
            return;

        if (listVal == null || !listVal.Any())
        {
            return;
        }

        // Remove excess children
        while (list.ChildCount > listVal.Length)
        {
            list.RemoveChild(list.GetChild(list.ChildCount - 1));
        }

        // Add missing children
        while (list.ChildCount < listVal.Length)
        {
            var child = new PowerMonitoringEntry();
            child.Orientation = BoxContainer.LayoutOrientation.Horizontal;
            child.HorizontalExpand = true;
            list.AddChild(child);

            var icon = new TextureRect();
            icon.VerticalAlignment = VAlignment.Center;
            icon.Margin = new Thickness(0, 0, 2, 0);
            child.Symbol = icon;

            child.AddChild(icon);

            var button = new PowerMonitoringButton();
            button.StyleClasses.Add("OpenBoth");
            child.Button = button;
            child.AddChild(button);

            button.OnButtonUp += args =>
            {
                ButtonAction(button, listVal.ElementAt(child.GetPositionInParent()), list);
            };
        }

        foreach (var child in list.Children)
        {
            if (child is not PowerMonitoringEntry)
                continue;

            var castChild = (PowerMonitoringEntry) child;
            if (castChild == null)
                continue;
            if (castChild.Button == null)
                continue;

            if (castChild.Symbol != null)
            {
                castChild.Symbol.Texture = _spriteSystem.Frame0
                    (new SpriteSpecifier.Texture(new(isSource ? PowerMonitoringHelper.SourceIconPath : PowerMonitoringHelper.LoadIconPath)));
            }

            UpdateEntry(castChild.Button, listVal.ElementAt(child.GetPositionInParent()), 0f);
        }
    }

    private Dictionary<Vector2i, List<ChunkedLine>> DecodePowerCableChunks(Dictionary<Vector2i, NavMapChunkPowerCables> chunks, List<CableData> cableData, MapGridComponent grid)
    {
        var output = new Dictionary<Vector2i, List<ChunkedLine>>();

        foreach ((var chunkOrigin, var chunk) in chunks)
        {
            var list = new List<ChunkedLine>();

            foreach (var datum in cableData)
            {
                for (var i = 0; i < SharedNavMapSystem.ChunkSize * SharedNavMapSystem.ChunkSize; i++)
                {
                    var value = (int) Math.Pow(2, i);
                    var mask = chunk.CableData[datum.CableType] & value;

                    if (mask == 0x0)
                        continue;

                    var relativeTile = SharedNavMapSystem.GetTile(mask);
                    var tile = (chunk.Origin * SharedNavMapSystem.ChunkSize + relativeTile) * grid.TileSize;
                    var position = new Vector2(tile.X, -tile.Y);
                    NavMapChunkPowerCables? neighborChunk;
                    bool neighbor;

                    // Only check the north and east neighbors

                    // East
                    if (relativeTile.X == SharedNavMapSystem.ChunkSize - 1)
                    {
                        neighbor = chunks.TryGetValue(chunkOrigin + new Vector2i(1, 0), out neighborChunk) &&
                                    (neighborChunk.CableData[datum.CableType] & SharedNavMapSystem.GetFlag(new Vector2i(0, relativeTile.Y))) != 0x0;
                    }
                    else
                    {
                        var flag = SharedNavMapSystem.GetFlag(relativeTile + new Vector2i(1, 0));
                        neighbor = (chunk.CableData[datum.CableType] & flag) != 0x0;
                    }

                    if (neighbor)
                    {
                        // Add points
                        var line = new ChunkedLine
                            (position + datum.Offset + new Vector2(grid.TileSize * 0.5f, -grid.TileSize * 0.5f),
                            position + new Vector2(1f, 0f) + datum.Offset + new Vector2(grid.TileSize * 0.5f, -grid.TileSize * 0.5f),
                            datum.Color);
                        list.Add(line);
                    }

                    // North
                    if (relativeTile.Y == SharedNavMapSystem.ChunkSize - 1)
                    {
                        neighbor = chunks.TryGetValue(chunkOrigin + new Vector2i(0, 1), out neighborChunk) &&
                                        (neighborChunk.CableData[datum.CableType] & SharedNavMapSystem.GetFlag(new Vector2i(relativeTile.X, 0))) != 0x0;
                    }
                    else
                    {
                        var flag = SharedNavMapSystem.GetFlag(relativeTile + new Vector2i(0, 1));
                        neighbor = (chunk.CableData[datum.CableType] & flag) != 0x0;
                    }

                    if (neighbor)
                    {
                        // Add points
                        var line = new ChunkedLine
                            (position + datum.Offset + new Vector2(grid.TileSize * 0.5f, -grid.TileSize * 0.5f),
                            position + new Vector2(0f, -1f) + datum.Offset + new Vector2(grid.TileSize * 0.5f, -grid.TileSize * 0.5f),
                            datum.Color);
                        list.Add(line);
                    }
                }

            }

            output.Add(chunkOrigin, list);
        }

        return output;
    }

    private Dictionary<Vector2i, List<ChunkedLine>> DecodeTileChunks(Dictionary<Vector2i, NavMapChunk> chunks, MapGridComponent grid)
    {
        var output = new Dictionary<Vector2i, List<ChunkedLine>>();

        foreach ((var chunkOrigin, var chunk) in chunks)
        {
            var list = new List<ChunkedLine>();

            // TODO: Okay maybe I should just use ushorts lmao...
            for (var i = 0; i < SharedNavMapSystem.ChunkSize * SharedNavMapSystem.ChunkSize; i++)
            {
                var value = (int) Math.Pow(2, i);

                var mask = chunk.TileData & value;

                if (mask == 0x0)
                    continue;

                // Alright now we'll work out our edges
                var relativeTile = SharedNavMapSystem.GetTile(mask);
                var tile = (chunk.Origin * SharedNavMapSystem.ChunkSize + relativeTile) * grid.TileSize;
                var position = new Vector2(tile.X, -tile.Y);
                NavMapChunk? neighborChunk;
                bool neighbor;

                // North edge
                if (relativeTile.Y == SharedNavMapSystem.ChunkSize - 1)
                {
                    neighbor = chunks.TryGetValue(chunkOrigin + new Vector2i(0, 1), out neighborChunk) &&
                                  (neighborChunk.TileData &
                                   SharedNavMapSystem.GetFlag(new Vector2i(relativeTile.X, 0))) != 0x0;
                }
                else
                {
                    var flag = SharedNavMapSystem.GetFlag(relativeTile + new Vector2i(0, 1));
                    neighbor = (chunk.TileData & flag) != 0x0;
                }

                if (!neighbor)
                {
                    // Add points
                    list.Add(new ChunkedLine(position + new Vector2(0f, -grid.TileSize), position + new Vector2(grid.TileSize, -grid.TileSize), Color.Cyan));
                }

                // East edge
                if (relativeTile.X == SharedNavMapSystem.ChunkSize - 1)
                {
                    neighbor = chunks.TryGetValue(chunkOrigin + new Vector2i(1, 0), out neighborChunk) &&
                               (neighborChunk.TileData &
                                SharedNavMapSystem.GetFlag(new Vector2i(0, relativeTile.Y))) != 0x0;
                }
                else
                {
                    var flag = SharedNavMapSystem.GetFlag(relativeTile + new Vector2i(1, 0));
                    neighbor = (chunk.TileData & flag) != 0x0;
                }

                if (!neighbor)
                {
                    // Add points
                    list.Add(new ChunkedLine(position + new Vector2(grid.TileSize, -grid.TileSize), position + new Vector2(grid.TileSize, 0f), Color.Cyan));
                }

                // South edge
                if (relativeTile.Y == 0)
                {
                    neighbor = chunks.TryGetValue(chunkOrigin + new Vector2i(0, -1), out neighborChunk) &&
                               (neighborChunk.TileData &
                                SharedNavMapSystem.GetFlag(new Vector2i(relativeTile.X, SharedNavMapSystem.ChunkSize - 1))) != 0x0;
                }
                else
                {
                    var flag = SharedNavMapSystem.GetFlag(relativeTile + new Vector2i(0, -1));
                    neighbor = (chunk.TileData & flag) != 0x0;
                }

                if (!neighbor)
                {
                    // Add points
                    list.Add(new ChunkedLine(position + new Vector2(grid.TileSize, 0f), position, Color.Cyan));
                }

                // West edge
                if (relativeTile.X == 0)
                {
                    neighbor = chunks.TryGetValue(chunkOrigin + new Vector2i(-1, 0), out neighborChunk) &&
                               (neighborChunk.TileData &
                                SharedNavMapSystem.GetFlag(new Vector2i(SharedNavMapSystem.ChunkSize - 1, relativeTile.Y))) != 0x0;
                }
                else
                {
                    var flag = SharedNavMapSystem.GetFlag(relativeTile + new Vector2i(-1, 0));
                    neighbor = (chunk.TileData & flag) != 0x0;
                }

                if (!neighbor)
                {
                    // Add point
                    list.Add(new ChunkedLine(position, position + new Vector2(0f, -grid.TileSize), Color.Cyan));
                }

                // Draw a diagonal line for interiors.
                list.Add(new ChunkedLine(position + new Vector2(0f, -grid.TileSize), position + new Vector2(grid.TileSize, 0f), Color.Cyan));
            }

            output.Add(chunkOrigin, list);
        }

        return output;
    }
}


public sealed class ChunkedLine
{
    public Vector2 Origin;
    public Vector2 Terminus;
    public Color Color;

    public ChunkedLine(Vector2 origin, Vector2 terminus, Color color)
    {
        Origin = origin;
        Terminus = terminus;
        Color = color;
    }
}

public sealed class PowerMonitoringEntry : BoxContainer
{
    public EntityUid EntityUid;
    public PowerMonitoringButton? Button;
    public GridContainer? MainGrid;
    public GridContainer? Sources;
    public GridContainer? Loads;
    public TextureRect? Symbol;
}


public sealed class PowerMonitoringButton : Button
{
    public int IndexInTable;
    public EntityUid? EntityUid;
    public EntityCoordinates? Coordinates;
    public GridContainer? Grid;
    public SpriteView? SpriteView;
    public Label? Name;
    public Label? Value;
}
