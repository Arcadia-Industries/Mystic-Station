using Content.Client.UserInterface.Controls;
using Content.Shared.Pinpointer;
using Content.Shared.Power;
using Robust.Client.AutoGenerated;
using Robust.Client.GameObjects;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Map;
using Robust.Shared.Map.Components;
using Robust.Shared.Timing;
using Robust.Shared.Utility;
using System.Linq;

namespace Content.Client.Power;

[GenerateTypedNameReferences]
public sealed partial class PowerMonitoringWindow : FancyWindow
{
    private readonly IEntityManager _entManager;
    private readonly SpriteSystem _spriteSystem;

    private float _updateTimer = 1.0f;
    private const float UpdateTime = 1.0f;

    private EntityUid? _trackedEntity;
    private float? _nextScrollValue;

    public event Action<NetEntity?>? RequestPowerMonitoringUpdateAction;

    public PowerMonitoringWindow(PowerMonitoringConsoleBoundUserInterface userInterface, EntityUid? mapUid)
    {
        RobustXamlLoader.Load(this);
        _entManager = IoCManager.Resolve<IEntityManager>();
        _spriteSystem = _entManager.System<SpriteSystem>();

        // Get grid uid
        if (_entManager.TryGetComponent<TransformComponent>(mapUid, out var xform))
            NavMap.MapUid = xform.GridUid;

        else
            NavMap.Visible = false;

        // Set UI tab titles
        MasterTabContainer.SetTabTitle(0, Loc.GetString("power-monitoring-window-label-sources"));
        MasterTabContainer.SetTabTitle(1, Loc.GetString("power-monitoring-window-label-smes"));
        MasterTabContainer.SetTabTitle(2, Loc.GetString("power-monitoring-window-label-substation"));
        MasterTabContainer.SetTabTitle(3, Loc.GetString("power-monitoring-window-label-apc"));

        // Set UI toggles
        ShowHVCable.OnToggled += _ => OnShowCableToggled(CableType.HighVoltage);
        ShowMVCable.OnToggled += _ => OnShowCableToggled(CableType.MediumVoltage);
        ShowLVCable.OnToggled += _ => OnShowCableToggled(CableType.Apc);

        NavMap.ShowCables = new Dictionary<CableType, bool>
        {
            [CableType.HighVoltage] = true,
            [CableType.MediumVoltage] = true,
            [CableType.Apc] = true,
        };

        // Turn off beacons (they obscure too much)
        NavMap.ShowBeacons = false;

        // Set power monitoring update request action
        RequestPowerMonitoringUpdateAction += userInterface.RequestPowerMonitoringUpdate;
    }

    private void OnShowCableToggled(CableType cableType)
    {
        NavMap.ShowCables[cableType] = !NavMap.ShowCables[cableType];
    }

    public void ShowEntites
        (double totalSources,
        double totalLoads,
        PowerMonitoringConsoleEntry[] allSources,
        PowerMonitoringConsoleEntry[] allLoads,
        PowerMonitoringConsoleEntry[] focusSources,
        PowerMonitoringConsoleEntry[] focusLoads,
        Dictionary<Vector2i, NavMapChunkPowerCables> powerCableChunks,
        Dictionary<Vector2i, NavMapChunkPowerCables>? focusCableChunks,
        EntityCoordinates? monitorCoords)
    {
        if (!_entManager.TryGetComponent<MapGridComponent>(NavMap.MapUid, out var grid))
            return;

        if (!_entManager.TryGetComponent<NavMapComponent>(NavMap.MapUid, out var navMap))
            return;

        // Reset nav map values
        NavMap.TrackedCoordinates.Clear();
        NavMap.TrackedEntities.Clear();
        NavMap.FocusCableNetwork = null;

        // Update nav map tile grid
        NavMap.TileGrid = NavMap.GetDecodedTileChunks(navMap.Chunks, grid);

        // Determine what color scheme to use
        bool useDarkColors = focusSources.Any() || focusLoads.Any();

        // Update nav map power cable networks
        NavMap.PowerCableNetwork = NavMap.GetDecodedPowerCableChunks(powerCableChunks, grid, useDarkColors);

        if (focusCableChunks != null)
            NavMap.FocusCableNetwork = NavMap.GetDecodedPowerCableChunks(focusCableChunks, grid);

        // Draw all sources on the map
        foreach (var source in allSources)
        {
            if (source.Coordinates == null)
                continue;

            AddTrackedEntityToNavMap(_entManager.GetEntity(source.NetEntity), _entManager.GetCoordinates(source.Coordinates.Value), source, useDarkColors);
        }

        // Draw all loads on the map
        foreach (var load in allLoads)
        {
            if (load.Coordinates == null)
                continue;

            AddTrackedEntityToNavMap(_entManager.GetEntity(load.NetEntity), _entManager.GetCoordinates(load.Coordinates.Value), load, useDarkColors);
        }

        // Draw the sources for the focused device
        foreach (var source in focusSources)
        {
            if (source.Coordinates == null)
                continue;

            AddTrackedEntityToNavMap(_entManager.GetEntity(source.NetEntity), _entManager.GetCoordinates(source.Coordinates.Value), source);
        }

        // Draw the loads for the focused device
        foreach (var load in focusLoads)
        {
            if (load.Coordinates == null)
                continue;

            AddTrackedEntityToNavMap(_entManager.GetEntity(load.NetEntity), _entManager.GetCoordinates(load.Coordinates.Value), load);
        }

        // Show monitor location
        var monitor = _spriteSystem.Frame0(new SpriteSpecifier.Texture(new(PowerMonitoringHelper.CircleIconPath)));

        if (monitorCoords != null)
            NavMap.TrackedEntities.Add(monitorCoords.Value, (true, Color.Cyan, monitor));

        // Update power status text
        TotalSources.Text = Loc.GetString("power-monitoring-window-value", ("value", totalSources));
        TotalLoads.Text = Loc.GetString("power-monitoring-window-value", ("value", totalLoads));
        TotalLoads.FontColorOverride = totalSources < totalLoads && !MathHelper.CloseToPercent(totalSources, totalLoads, 0.1f) ? new Color(180, 0, 0) : Color.White;

        // Update generator list
        UpdateAllConsoleEntries(SourcesList, allSources, null, focusLoads);

        // Update SMES list
        var smesList = allLoads.Where(x => x.Group == PowerMonitoringConsoleGroup.SMES);
        UpdateAllConsoleEntries(SMESList, smesList.ToArray(), focusSources, focusLoads);

        // Update substation list
        var substationList = allLoads.Where(x => x.Group == PowerMonitoringConsoleGroup.Substation);
        UpdateAllConsoleEntries(SubstationList, substationList.ToArray(), focusSources, focusLoads);

        // Update APC list
        var apcList = allLoads.Where(x => x.Group == PowerMonitoringConsoleGroup.APC);
        UpdateAllConsoleEntries(ApcList, apcList.ToArray(), focusSources, null);
    }

    private void AddTrackedEntityToNavMap(EntityUid uid, EntityCoordinates coords, PowerMonitoringConsoleEntry entry, bool useDarkColors = false)
    {
        if (!NavMap.Visible)
            return;

        var colorMap = useDarkColors ? PowerMonitoringHelper.DarkPowerIconColors : PowerMonitoringHelper.PowerIconColors;
        var color = uid == _trackedEntity ? Color.White : colorMap[entry.Group];

        var iconPath = PowerMonitoringHelper.CircleIconPath;

        switch (entry.Group)
        {
            case PowerMonitoringConsoleGroup.Generator:
                iconPath = PowerMonitoringHelper.CircleIconPath; break;
            case PowerMonitoringConsoleGroup.SMES:
                iconPath = PowerMonitoringHelper.HexagonIconPath; break;
            case PowerMonitoringConsoleGroup.Substation:
                iconPath = PowerMonitoringHelper.SquareIconPath; break;
            case PowerMonitoringConsoleGroup.APC:
                iconPath = PowerMonitoringHelper.TriangleIconPath; break;
        }

        var icon = _spriteSystem.Frame0(new SpriteSpecifier.Texture(new(iconPath)));

        // We expect a single tracked entity at a given coordinate
        if (NavMap.TrackedEntities.ContainsKey(coords))
            NavMap.TrackedEntities[coords] = (true, color, icon);

        else
            NavMap.TrackedEntities.Add(coords, (true, color, icon));
    }

    protected override void FrameUpdate(FrameEventArgs args)
    {
        TryToScrollToFocus();

        _updateTimer += args.DeltaSeconds;

        if (_updateTimer >= UpdateTime)
        {
            _updateTimer -= UpdateTime;
            RequestPowerMonitoringUpdateAction?.Invoke(_entManager.GetNetEntity(_trackedEntity));
        }
    }
}
