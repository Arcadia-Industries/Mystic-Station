using Content.Client.Pinpointer.UI;
using Content.Client.UserInterface.Controls;
using Content.Shared.Pinpointer;
using Content.Shared.Power;
using Robust.Client.AutoGenerated;
using Robust.Client.GameObjects;
using Robust.Client.ResourceManagement;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Map;
using Robust.Shared.Map.Components;
using Robust.Shared.Timing;
using Robust.Shared.Utility;
using System.Linq;

namespace Content.Client.Power;

[GenerateTypedNameReferences]
public sealed partial class PowerMonitoringWindow : FancyWindow
{
    private readonly IEntityManager _entManager;
    private readonly SpriteSystem _spriteSystem;
    private readonly IGameTiming _gameTiming;

    private float _updateTimer = 1.0f;
    private const float UpdateTime = 1.0f;
    private const float BlinkFrequency = 1f;

    private EntityUid? _owner;
    private EntityUid? _trackedEntity;
    private List<PowerMonitoringConsoleEntry> _allEntries = new();

    private Color _wallColor = new Color(102, 164, 217);
    private Color _tileColor = new Color(30, 57, 67);

    public event Action<NetEntity?>? RequestPowerMonitoringUpdateAction;

    public PowerMonitoringWindow(PowerMonitoringConsoleBoundUserInterface userInterface, EntityUid? owner)
    {
        RobustXamlLoader.Load(this);
        var cache = IoCManager.Resolve<IResourceCache>();
        _entManager = IoCManager.Resolve<IEntityManager>();
        _gameTiming = IoCManager.Resolve<IGameTiming>();
        _spriteSystem = _entManager.System<SpriteSystem>();

        _owner = owner;

        if (_entManager.TryGetComponent<PowerMonitoringConsoleComponent>(owner, out var powerMonitoringConsole))
            NavMap.PowerMonitoringConsole = powerMonitoringConsole;

        // Get grid uid
        if (_entManager.TryGetComponent<TransformComponent>(owner, out var xform))
        {
            NavMap.MapUid = xform.GridUid;

            // Assign station name      
            var stationName = Loc.GetString("power-monitoring-window-unknown-location");

            if (_entManager.TryGetComponent<MetaDataComponent>(xform.GridUid, out var stationMetaData))
                stationName = stationMetaData.EntityName;

            var msg = new FormattedMessage();
            msg.AddMarkup(Loc.GetString("power-monitoring-window-station-name", ("stationName", stationName)));

            StationName.SetMessage(msg);
        }
        else
        {
            StationName.SetMessage(Loc.GetString("power-monitoring-window-unknown-location"));
            NavMap.Visible = false;
        }

        // Set UI tab titles
        MasterTabContainer.SetTabTitle(0, Loc.GetString("power-monitoring-window-label-sources"));
        MasterTabContainer.SetTabTitle(1, Loc.GetString("power-monitoring-window-label-smes"));
        MasterTabContainer.SetTabTitle(2, Loc.GetString("power-monitoring-window-label-substation"));
        MasterTabContainer.SetTabTitle(3, Loc.GetString("power-monitoring-window-label-apc"));

        // Set UI toggles
        ShowHVCable.OnToggled += _ => OnShowCableToggled(NavMapLineGroup.HighVoltage);
        ShowMVCable.OnToggled += _ => OnShowCableToggled(NavMapLineGroup.MediumVoltage);
        ShowLVCable.OnToggled += _ => OnShowCableToggled(NavMapLineGroup.Apc);

        // Set colors
        NavMap.TileColor = _tileColor;
        NavMap.WallColor = _wallColor;

        // Set power monitoring update request action
        RequestPowerMonitoringUpdateAction += userInterface.RequestPowerMonitoringUpdate;

        // Set trackable entity selected action
        NavMap.TrackableEntitySelectedAction += SetTrackedEntityFromNavMap;
    }

    private void OnShowCableToggled(NavMapLineGroup lineGroup)
    {
        if (NavMap.HiddenLineGroups.Contains(lineGroup))
            NavMap.HiddenLineGroups.Remove(lineGroup);
        else
            NavMap.HiddenLineGroups.Add(lineGroup);
    }

    public void ShowEntites
        (double totalSources,
        double totalBatteryUsage,
        double totalLoads,
        PowerMonitoringConsoleEntry[] allEntries,
        PowerMonitoringConsoleEntry[] focusSources,
        PowerMonitoringConsoleEntry[] focusLoads,
        PowerMonitoringFlags flags,
        EntityCoordinates? monitorCoords)
    {
        if (!_entManager.TryGetComponent<MapGridComponent>(NavMap.MapUid, out var grid))
            return;

        // Reset nav map values
        NavMap.TrackedCoordinates.Clear();
        NavMap.TrackedEntities.Clear();
        NavMap.FocusCableNetwork = null;
        _allEntries = allEntries.ToList();

        // Draw all entities on the map
        foreach (var entry in allEntries)
        {
            if (entry.Coordinates == null)
                continue;

            AddTrackedEntityToNavMap(_entManager.GetEntity(entry.NetEntity), _entManager.GetCoordinates(entry.Coordinates.Value), _trackedEntity != null);
        }

        // Draw the sources for the focused device
        foreach (var source in focusSources)
        {
            if (source.Coordinates == null)
                continue;

            AddTrackedEntityToNavMap(_entManager.GetEntity(source.NetEntity), _entManager.GetCoordinates(source.Coordinates.Value));
        }

        // Draw the loads for the focused device
        foreach (var load in focusLoads)
        {
            if (load.Coordinates == null)
                continue;

            AddTrackedEntityToNavMap(_entManager.GetEntity(load.NetEntity), _entManager.GetCoordinates(load.Coordinates.Value));
        }

        // Show monitor location
        if (monitorCoords != null && _entManager.TryGetComponent<NavMapTrackableComponent>(_owner, out var trackable))
            NavMap.TrackedEntities[monitorCoords.Value] = trackable;

        // Update power status text
        TotalSources.Text = Loc.GetString("power-monitoring-window-value", ("value", totalSources));
        TotalBatteryUsage.Text = Loc.GetString("power-monitoring-window-value", ("value", totalBatteryUsage));
        TotalLoads.Text = Loc.GetString("power-monitoring-window-value", ("value", totalLoads));

        // 10+% of station power is being drawn from batteries
        TotalBatteryUsage.FontColorOverride = (totalSources * 0.1111f) < totalBatteryUsage ? new Color(180, 0, 0) : Color.White;

        // Station generator and battery output is less than the current demand
        TotalLoads.FontColorOverride = (totalSources + totalBatteryUsage) < totalLoads &&
            !MathHelper.CloseToPercent(totalSources + totalBatteryUsage, totalLoads, 0.1f) ? new Color(180, 0, 0) : Color.White;

        // Update lists
        var generatorList = allEntries.Where(x => x.Group == PowerMonitoringConsoleGroup.Generator);
        UpdateAllConsoleEntries(SourcesList, generatorList.ToArray(), null, focusLoads);

        var smesList = allEntries.Where(x => x.Group == PowerMonitoringConsoleGroup.SMES);
        UpdateAllConsoleEntries(SMESList, smesList.ToArray(), focusSources, focusLoads);

        var substationList = allEntries.Where(x => x.Group == PowerMonitoringConsoleGroup.Substation);
        UpdateAllConsoleEntries(SubstationList, substationList.ToArray(), focusSources, focusLoads);

        var apcList = allEntries.Where(x => x.Group == PowerMonitoringConsoleGroup.APC);
        UpdateAllConsoleEntries(ApcList, apcList.ToArray(), focusSources, null);

        // Update system warnings
        UpdateWarningLabel(flags);

        // Update power cable overlay
        NavMap.UpdatePowerCableChunks();
    }

    private void AddTrackedEntityToNavMap(EntityUid uid, EntityCoordinates coords, bool useDarkColors = false)
    {
        if (!NavMap.Visible)
            return;

        // We expect a single tracked entity at a given coordinate
        if (_entManager.TryGetComponent<NavMapTrackableComponent>(uid, out var trackable))
        {
            trackable.Modulate = uid != _trackedEntity && useDarkColors ? Color.DimGray : Color.White;
            trackable.Blinks = uid == _trackedEntity;
            NavMap.TrackedEntities[coords] = trackable;
        }
    }

    private void SetTrackedEntityFromNavMap(EntityCoordinates? coords, NavMapTrackableComponent? trackable)
    {
        _trackedEntity = trackable?.Owner;

        // Try to find entry
        var netEntity = _entManager.GetNetEntity(_trackedEntity);
        var entry = _allEntries.FirstOrDefault(x => x.NetEntity == netEntity);

        if (entry != null)
        {
            // Switch tabs
            switch (entry.Group)
            {
                case PowerMonitoringConsoleGroup.Generator:
                    MasterTabContainer.CurrentTab = 0; break;
                case PowerMonitoringConsoleGroup.SMES:
                    MasterTabContainer.CurrentTab = 1; break;
                case PowerMonitoringConsoleGroup.Substation:
                    MasterTabContainer.CurrentTab = 2; break;
                case PowerMonitoringConsoleGroup.APC:
                    MasterTabContainer.CurrentTab = 3; break;
            }

            // Get the scroll position of the selected entity on the selected button the UI
            _tryToScroll = true;
        }

        // Request new data
        RequestPowerMonitoringUpdateAction?.Invoke(_entManager.GetNetEntity(_trackedEntity));
        _updateTimer = 0f;
    }

    protected override void FrameUpdate(FrameEventArgs args)
    {
        TryToScrollToFocus();

        _updateTimer += args.DeltaSeconds;

        // Warning sign pulse        
        var lit = _gameTiming.RealTime.TotalSeconds % BlinkFrequency > BlinkFrequency / 2f;
        SystemWarningPanel.Modulate = lit ? Color.White : new Color(178, 178, 178);

        if (_updateTimer >= UpdateTime)
        {
            _updateTimer -= UpdateTime;

            // Request update from power monitoring system
            RequestPowerMonitoringUpdateAction?.Invoke(_entManager.GetNetEntity(_trackedEntity));
        }
    }
}
