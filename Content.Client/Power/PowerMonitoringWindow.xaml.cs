using System.Linq;
using System.Numerics;
using Content.Client.Pinpointer.UI;
using Content.Client.Stylesheets;
using Content.Client.UserInterface.Controls;
using Content.Shared.Pinpointer;
using Content.Shared.Power;
using Robust.Client.AutoGenerated;
using Robust.Client.GameObjects;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Client.Utility;
using Robust.Shared.Map;
using Robust.Shared.Map.Components;
using Robust.Shared.Timing;
using Robust.Shared.Utility;

namespace Content.Client.Power;

[GenerateTypedNameReferences]
public sealed partial class PowerMonitoringWindow : FancyWindow
{
    private List<Control> _rowsContent = new();
    private readonly IEntityManager _entManager;
    private EntityUid? _stationUid;
    private EntityUid? _trackedEntity;
    private readonly SpriteSystem _spriteSystem = default!;
    private readonly MetaDataSystem _metaDataSystem = default!;

    private float _updateTimer = 1.0f;
    private const float UpdateTime = 1.0f;

    private int nameCharLimit = 25;
    private float? _nextScrollStart;

    public static int IconSize = 16; // XAML has a `VSeparationOverride` of 20 for each row.
    public event Action<NetEntity?>? RequestPowerMonitoringDataAction;

    private List<CableData> _cableData = new List<CableData>()
    {
        new CableData(CableType.HighVoltage, Color.Orange),
        new CableData(CableType.MediumVoltage, Color.Yellow, new Vector2(-0.2f, -0.2f)),
        new CableData(CableType.Apc, Color.LimeGreen, new Vector2(0.2f, 0.2f)),
    };

    private List<CableData> _unfocusCableData = new List<CableData>()
    {
        //new CableData(CableType.HighVoltage, new Color(190,122,0)),
        //new CableData(CableType.MediumVoltage, new Color(135,135,0), new Vector2(-0.2f, -0.2f)),
        //new CableData(CableType.Apc, new Color(30,115,30), new Vector2(0.2f, 0.2f)),
        new CableData(CableType.HighVoltage, new Color(82,52,0)),
        new CableData(CableType.MediumVoltage, new Color(80,80,0), new Vector2(-0.2f, -0.2f)),
        new CableData(CableType.Apc, new Color(20,76,20), new Vector2(0.2f, 0.2f)),
    };

    public PowerMonitoringWindow(PowerMonitoringConsoleBoundUserInterface userInterface, EntityUid? mapUid)
    {
        RobustXamlLoader.Load(this);
        _entManager = IoCManager.Resolve<IEntityManager>();
        _stationUid = mapUid;
        _spriteSystem = IoCManager.Resolve<IEntityManager>().System<SpriteSystem>();
        _metaDataSystem = IoCManager.Resolve<IEntityManager>().System<MetaDataSystem>();

        if (_entManager.TryGetComponent<TransformComponent>(mapUid, out var xform))
        {
            NavMap.MapUid = xform.GridUid;
        }

        else
        {
            NavMap.Visible = false;
            SetSize = new Vector2(775, 400);
            MinSize = SetSize;
        }

        NavMap.ShowCables = new Dictionary<CableType, bool>
        {
            [CableType.HighVoltage] = true,
            [CableType.MediumVoltage] = true,
            [CableType.Apc] = true,
        };

        // Set UI tab titles
        MasterTabContainer.SetTabTitle(0, Loc.GetString("power-monitoring-window-label-sources"));
        MasterTabContainer.SetTabTitle(1, Loc.GetString("power-monitoring-window-label-smes"));
        MasterTabContainer.SetTabTitle(2, Loc.GetString("power-monitoring-window-label-substation"));
        MasterTabContainer.SetTabTitle(3, Loc.GetString("power-monitoring-window-label-apc"));

        // Set UI toggles
        ShowHVCable.OnToggled += _ => OnShowCableToggled(ShowHVCable, CableType.HighVoltage);
        ShowMVCable.OnToggled += _ => OnShowCableToggled(ShowMVCable, CableType.MediumVoltage);
        ShowLVCable.OnToggled += _ => OnShowCableToggled(ShowLVCable, CableType.Apc);

        NavMap.ShowBeacons = false;

        // Set power monitoring data request action
        RequestPowerMonitoringDataAction += userInterface.RequestPowerMonitoringData;
    }

    private void OnShowCableToggled(CheckBox checkBox, CableType cableType)
    {
        NavMap.ShowCables[cableType] = !NavMap.ShowCables[cableType];
    }

    public void ShowEntites
        (float totalSources,
        float totalLoads,
        PowerMonitoringConsoleEntry[] sources,
        PowerMonitoringConsoleEntry[] loads,
        PowerMonitoringConsoleEntry[] _sources,
        PowerMonitoringConsoleEntry[] _loads,
        Dictionary<Vector2i, NavMapChunkPowerCables> powerCableChunks,
        Dictionary<Vector2i, NavMapChunkPowerCables>? focusPowerCableChunks,
        EntityCoordinates? monitorCoords)
    {
        ClearAllSensors();

        NavMap.PowerCableChunks = powerCableChunks;
        NavMap.FocusPowerCableChunks = focusPowerCableChunks;

        if (!_entManager.TryGetComponent<MapGridComponent>(NavMap.MapUid, out var grid))
            return;

        if (!_entManager.TryGetComponent<NavMapComponent>(NavMap.MapUid, out var navMap))
            return;

        if (focusPowerCableChunks != null && focusPowerCableChunks.Any())
        {
            NavMap.CableGrid = DecodePowerCableChunks(powerCableChunks, _unfocusCableData, grid);
            NavMap.FocusGrid = DecodePowerCableChunks(focusPowerCableChunks, _cableData, grid);
        }
        else
        {
            NavMap.CableGrid = DecodePowerCableChunks(powerCableChunks, _cableData, grid);
            NavMap.FocusGrid = default!;
        }

        NavMap.TileGrid = DecodeTileChunks(navMap.Chunks, grid);

        TotalSources.Text = Loc.GetString("power-monitoring-window-value", ("value", totalSources));
        TotalLoads.Text = Loc.GetString("power-monitoring-window-value", ("value", totalLoads));

        TotalLoads.FontColorOverride = totalSources < totalLoads && !MathHelper.CloseToPercent(totalSources, totalLoads, 0.1f) ? new Color(180, 0, 0) : Color.White;

        UpdateChildren(SourcesList, sources, null, _loads);

        var apcList = loads.Where(x => x.IconEntityPrototypeId.Contains("APC"));
        UpdateChildren(ApcList, apcList.ToArray(), _sources, null);

        var substationList = loads.Where(x => x.IconEntityPrototypeId.Contains("Substation"));
        UpdateChildren(SubstationList, substationList.ToArray(), _sources, _loads);

        var smesList = loads.Where(x => x.IconEntityPrototypeId.Contains("SMES"));
        UpdateChildren(SMESList, smesList.ToArray(), _sources, _loads);


        foreach (var source in sources)
        {
            AddTrackedEntity(_entManager.GetEntity(source.NetEntity), _entManager.GetCoordinates(source.Coordinates), source);

            if ((_sources == null || !_sources.Any()) &&
                (_loads == null || !_loads.Any()))
                AddTrackedHighlighted(_entManager.GetEntity(source.NetEntity), _entManager.GetCoordinates(source.Coordinates), source);
        }

        foreach (var load in loads)
        {
            AddTrackedEntity(_entManager.GetEntity(load.NetEntity), _entManager.GetCoordinates(load.Coordinates), load);

            if ((_sources == null || !_sources.Any()) &&
                (_loads == null || !_loads.Any()))
                AddTrackedHighlighted(_entManager.GetEntity(load.NetEntity), _entManager.GetCoordinates(load.Coordinates), load);
        }

        foreach (var source in _sources)
        {
            AddTrackedHighlighted(_entManager.GetEntity(source.NetEntity), _entManager.GetCoordinates(source.Coordinates), source);

            //SpawnEntry(source, SourcesList);
        }

        foreach (var load in _loads)
        {
            AddTrackedHighlighted(_entManager.GetEntity(load.NetEntity), _entManager.GetCoordinates(load.Coordinates), load);

            //SpawnEntry(source, SourcesList);
        }

        // add a row for each sensor
        /*foreach (var load in loads)
        {
            var entity = _entManager.GetEntity(load.NetEntity);
            var coordinates = _entManager.GetCoordinates(load.Coordinates);

            // add button with username
            var nameButton = new PowerMonitoringButton()
            {
                entityUid = entity,
                Coordinates = coordinates,
                Text = load.NameLocalized,
                Margin = new Thickness(5f, 5f),
            };

            if (entity == _trackedButton?.entityUid)
                nameButton.AddStyleClass(StyleNano.StyleClassButtonColorGreen);

            //SensorsTable.AddChild(nameButton);
            //_rowsContent.Add(nameButton);

            var powerLabel = new Label();
            powerLabel.Text = load.Size.ToString();

            //SensorsTable.AddChild(powerLabel);
            //_rowsContent.Add(powerLabel);

            IRsiStateLike? iconState = null;
            if (load.IconEntityPrototypeId != null)
                iconState = _spriteSystem.GetPrototypeIcon(load.IconEntityPrototypeId);
            if (load.IconEntityPrototypeId == null)
                continue;

            if (coordinates != null && NavMap.Visible)
            {
                //NavMap.TrackedEntities.TryAdd(coordinates,
                //    (true, entity == _trackedButton?.entityUid ? StyleNano.PointGreen : Color.White, iconState?.TextureFor(Direction.South)));

                //NavMap.TrackedCoordinates.TryAdd(coordinates,
                //    (true, entity == _trackedButton?.entityUid ? Color.White : color));

                //NavMap.TrackedEntities.TryAdd(coordinates,
                //    (true, entity == _trackedButton?.entityUid ? Color.White : color, icon));

                nameButton.OnButtonUp += args =>
                {
                    if (_trackedButton != null && _trackedButton?.Coordinates != null)
                        NavMap.TrackedCoordinates[_trackedButton.Coordinates.Value] = (true, color);
                    //NavMap.TrackedEntities[_trackedButton.Coordinates.Value] = (true, Color.White, iconState?.TextureFor(Direction.South));

                    NavMap.TrackedCoordinates[coordinates] = (true, Color.White);
                    //NavMap.TrackedEntities[coordinates] = (true, StyleNano.PointGreen, iconState?.TextureFor(Direction.South));
                    NavMap.CenterToCoordinates(coordinates);

                    nameButton.AddStyleClass(StyleNano.StyleClassButtonColorGreen);
                    if (_trackedButton != null)
                    {   //Make previous button default
                        var previousButton = SensorsTable.GetChild(_trackedButton.IndexInTable);
                        previousButton.RemoveStyleClass(StyleNano.StyleClassButtonColorGreen);
                    }

                    _trackedButton = nameButton;
                    _trackedButton.IndexInTable = nameButton.GetPositionInParent();
                };
            }
        }*/

        // Show monitor point
        var icon1 = new SpriteSpecifier.Texture(new("/Textures/Interface/PowerMonitoring/beveled_circle.png")).Frame0();

        if (monitorCoords != null)
            NavMap.TrackedEntities.Add(monitorCoords.Value, (true, Color.Cyan, icon1));
    }

    private void AddTrackedEntity(EntityUid uid, EntityCoordinates coords, PowerMonitoringConsoleEntry entry)
    {
        if (!NavMap.Visible)
            return;

        var color = new Color(54, 0, 54);
        var icon = new SpriteSpecifier.Texture(new("/Textures/Interface/PowerMonitoring/beveled_circle.png")).Frame0();

        if (entry.IconEntityPrototypeId.Contains("APC"))
        {
            color = new Color(20, 76, 20);
            icon = new SpriteSpecifier.Texture(new("/Textures/Interface/PowerMonitoring/beveled_triangle.png")).Frame0();
        }

        else if (entry.IconEntityPrototypeId.Contains("Substation"))
        {
            color = new Color(80, 80, 0);
            icon = new SpriteSpecifier.Texture(new("/Textures/Interface/PowerMonitoring/beveled_square.png")).Frame0();
        }

        else if (entry.IconEntityPrototypeId.Contains("SMES"))
        {
            color = new Color(82, 52, 0);
            icon = new SpriteSpecifier.Texture(new("/Textures/Interface/PowerMonitoring/beveled_hexagon.png")).Frame0();
        }

        color = uid == _trackedEntity ? Color.White : color;
        NavMap.TrackedEntities.TryAdd(coords, (true, color, icon));
    }

    private void AddTrackedHighlighted(EntityUid uid, EntityCoordinates coords, PowerMonitoringConsoleEntry entry)
    {
        if (!NavMap.Visible)
            return;

        if (NavMap.TrackedEntities.TryGetValue(coords, out var tracked))
        {
            tracked.Color = Color.Purple;

            if (entry.IconEntityPrototypeId.Contains("APC"))
            {
                tracked.Color = Color.LimeGreen;
            }

            else if (entry.IconEntityPrototypeId.Contains("Substation"))
            {
                tracked.Color = Color.Yellow;
            }

            else if (entry.IconEntityPrototypeId.Contains("SMES"))
            {
                tracked.Color = Color.Orange;
            }

            tracked.Color = uid == _trackedEntity ? Color.White : tracked.Color;
            NavMap.TrackedEntities[coords] = tracked;
        }
    }

    protected override void FrameUpdate(FrameEventArgs args)
    {
        if (_nextScrollStart != null)
        {
            var scroll = MasterTabContainer.Children.ElementAt(MasterTabContainer.CurrentTab) as ScrollContainer;
            if (scroll == null)
                return;

            scroll.SetScrollValue(new Vector2(0, _nextScrollStart.Value));

            Logger.Debug("applied scroll: " + _nextScrollStart);
            _nextScrollStart = null;
        }

        _updateTimer += args.DeltaSeconds;

        if (_updateTimer >= UpdateTime)
        {
            _updateTimer -= UpdateTime;
            RequestPowerMonitoringDataAction?.Invoke(_entManager.GetNetEntity(_trackedEntity));
        }
    }

    private void ClearAllSensors()
    {
        foreach (var child in _rowsContent)
        {
            //SensorsTable.RemoveChild(child);
        }

        _rowsContent.Clear();
        NavMap.TrackedCoordinates.Clear();
        NavMap.TrackedEntities.Clear();
    }

    public void UpdateEntry(PowerMonitoringButton child, PowerMonitoringConsoleEntry entry, float offset = 38f)
    {
        var uid = _entManager.GetEntity(entry.NetEntity);
        child.EntityUid = uid;
        child.HorizontalExpand = true;
        //child.SetHeight = 40;

        if (uid == _trackedEntity)
        {
            child.AddStyleClass(StyleNano.StyleClassButtonColorGreen);
        }

        else
        {
            child.RemoveStyleClass(StyleNano.StyleClassButtonColorGreen);
        }

        child.ToolTip = Loc.GetString(entry.NameLocalized);

        if (child.Grid == null)
        {
            child.Grid = new GridContainer
            {
                Columns = 3,
            };

            child.AddChild(child.Grid);
        }

        if (child.SpriteView == null)
        {
            child.SpriteView = new SpriteView();
            child.Grid.AddChild(child.SpriteView);
        }

        child.SpriteView.SetEntity(uid);
        child.SpriteView.OverrideDirection = Direction.South;
        child.SpriteView.SetSize = new Vector2(32f, 32f);

        if (child.Name == null)
        {
            child.Name = new Label();
            child.Grid.AddChild(child.Name);
        }

        child.Name.MinWidth = 220f + offset;
        child.Name.MaxWidth = 220f + offset;
        child.Name.ClipText = true;

        var name = Loc.GetString(entry.NameLocalized);
        var _charLimit = (int) (child.Name.MaxWidth / 8f);
        if (name.Length > _charLimit)
            name = $"{name.Substring(0, _charLimit - 3)}...";

        child.Name.Text = name;

        if (child.Value == null)
        {
            child.Value = new Label();
            child.Grid.AddChild(child.Value);
        }

        child.Value.Text = Loc.GetString("power-monitoring-window-value", ("value", entry.Size));
        child.Value.MinWidth = 64f;
    }

    private void ButtonAction(PowerMonitoringButton child, PowerMonitoringConsoleEntry entry, GridContainer list)
    {
        if (child.EntityUid == _trackedEntity)
        {
            child.RemoveStyleClass(StyleNano.StyleClassButtonColorGreen);
            _trackedEntity = null;

            return;
        }

        child.AddStyleClass(StyleNano.StyleClassButtonColorGreen);

        NavMap.CenterToCoordinates(_entManager.GetCoordinates(entry.Coordinates));

        if (_trackedEntity != null)
        {
            foreach (PowerMonitoringEntry sibling in list.Children)
            {
                if (sibling.Button != null && sibling.Button.EntityUid == _trackedEntity)
                {
                    sibling.RemoveStyleClass(StyleNano.StyleClassButtonColorGreen);
                    break;
                }
            }
        }

        _trackedEntity = child.EntityUid;
        RequestPowerMonitoringDataAction?.Invoke(_entManager.GetNetEntity(_trackedEntity));
        _updateTimer = 0f;

        if (entry.IconEntityPrototypeId.Contains("APC"))
        {
            MasterTabContainer.CurrentTab = 3;
        }
        else if (entry.IconEntityPrototypeId.Contains("Substation"))
        {
            MasterTabContainer.CurrentTab = 2;
        }
        else if (entry.IconEntityPrototypeId.Contains("SMES"))
        {
            MasterTabContainer.CurrentTab = 1;
        }
        else
        {
            MasterTabContainer.CurrentTab = 0;
        }

        var scroll = MasterTabContainer.Children.ElementAt(MasterTabContainer.CurrentTab) as ScrollContainer;
        if (scroll == null)
            return;

        var grid = scroll.Children.ElementAt(0) as GridContainer;
        if (grid == null)
            return;

        var pos = grid.Children.FirstOrDefault(x => (x is PowerMonitoringEntry) && ((PowerMonitoringEntry) x).EntityUid == _trackedEntity);
        if (pos == null)
            return;

        _nextScrollStart = 40f * pos.GetPositionInParent();
    }

    private void UpdateChildren(GridContainer list, PowerMonitoringConsoleEntry[] listVal, PowerMonitoringConsoleEntry[]? sources, PowerMonitoringConsoleEntry[]? loads)
    {
        // Remove excess children
        while (list.ChildCount > listVal.Length)
        {
            list.RemoveChild(list.GetChild(list.ChildCount - 1));
        }

        if (!listVal.Any())
            return;

        // Add missing children
        while (list.ChildCount < listVal.Length)
        {
            var child = new PowerMonitoringEntry();
            child.Orientation = BoxContainer.LayoutOrientation.Vertical;
            child.HorizontalExpand = true;
            list.AddChild(child);

            var ent = _entManager.GetEntity(listVal.ElementAt(child.GetPositionInParent()).NetEntity);
            child.EntityUid = ent;

            var button = new PowerMonitoringButton();
            button.StyleClasses.Add("OpenLeft");
            child.Button = button;
            child.AddChild(button);

            button.OnButtonUp += args =>
            {
                ButtonAction(button, listVal.ElementAt(child.GetPositionInParent()), list);
            };

            var grid = new GridContainer();
            grid.Columns = 1;
            grid.HorizontalExpand = true;
            grid.Margin = new Thickness(8, 5, 0, 0);
            grid.Visible = false;
            child.MainGrid = grid;
            child.AddChild(grid);

            var subgridSources = new GridContainer();
            subgridSources.Columns = 1;
            subgridSources.HorizontalExpand = true;
            subgridSources.Margin = new Thickness(0, 0, 0, 0);
            child.Sources = subgridSources;
            grid.AddChild(subgridSources);

            var subgridLoads = new GridContainer();
            subgridLoads.Columns = 1;
            subgridLoads.HorizontalExpand = true;
            subgridLoads.Margin = new Thickness(0, 0, 0, 0);
            child.Loads = subgridLoads;
            grid.AddChild(subgridLoads);

            var spacer = new Control();
            spacer.Margin = new Thickness(0, 0, 0, 5);
        }

        foreach (var child in list.Children)
        {
            if (child is not PowerMonitoringEntry)
                continue;

            var castChild = (PowerMonitoringEntry) child;
            if (castChild == null)
                continue;
            if (castChild.Button == null)
                continue;

            var entry = listVal.ElementAt(child.GetPositionInParent());
            var ent = _entManager.GetEntity(entry.NetEntity);

            UpdateEntry(castChild.Button, listVal.ElementAt(child.GetPositionInParent()));

            if (castChild.MainGrid == null)
                continue;

            if (_trackedEntity == ent)
            {
                castChild.MainGrid.Visible = true;
                UpdateEntrySourcesLoads(castChild.Sources, sources);
                UpdateEntrySourcesLoads(castChild.Loads, loads, false);
            }

            else
                castChild.MainGrid.Visible = false;
        }
    }

    private void UpdateEntrySourcesLoads(GridContainer? list, PowerMonitoringConsoleEntry[]? listVal, bool isSource = true)
    {
        if (list == null)
            return;

        if (listVal == null || !listVal.Any())
        {
            return;
        }

        // Remove excess children
        while (list.ChildCount > listVal.Length)
        {
            list.RemoveChild(list.GetChild(list.ChildCount - 1));
        }

        // Add missing children
        while (list.ChildCount < listVal.Length)
        {
            var child = new PowerMonitoringEntry();
            child.Orientation = BoxContainer.LayoutOrientation.Horizontal;
            child.HorizontalExpand = true;
            list.AddChild(child);

            var icon = new TextureRect();
            icon.VerticalAlignment = VAlignment.Center;
            icon.Margin = new Thickness(0, 0, 2, 0);
            child.Symbol = icon;

            child.AddChild(icon);

            var button = new PowerMonitoringButton();
            button.StyleClasses.Add("OpenBoth");
            child.Button = button;
            child.AddChild(button);

            button.OnButtonUp += args =>
            {
                ButtonAction(button, listVal.ElementAt(child.GetPositionInParent()), list);
            };
        }

        foreach (var child in list.Children)
        {
            if (child is not PowerMonitoringEntry)
                continue;

            var castChild = (PowerMonitoringEntry) child;
            if (castChild == null)
                continue;
            if (castChild.Button == null)
                continue;

            if (castChild.Symbol != null)
            {
                if (isSource)
                    castChild.Symbol.Texture = new SpriteSpecifier.Texture(new("/Textures/Interface/PowerMonitoring/source_arrow.png")).Frame0();
                else
                    castChild.Symbol.Texture = new SpriteSpecifier.Texture(new("/Textures/Interface/PowerMonitoring/load_arrow.png")).Frame0();
            }

            UpdateEntry(castChild.Button, listVal.ElementAt(child.GetPositionInParent()), 0f);
        }
    }

    private Dictionary<Vector2i, List<ChunkedLine>> DecodePowerCableChunks(Dictionary<Vector2i, NavMapChunkPowerCables> chunks, List<CableData> cableData, MapGridComponent grid)
    {
        var output = new Dictionary<Vector2i, List<ChunkedLine>>();

        foreach ((var chunkOrigin, var chunk) in chunks)
        {
            var list = new List<ChunkedLine>();

            foreach (var datum in cableData)
            {
                for (var i = 0; i < SharedNavMapSystem.ChunkSize * SharedNavMapSystem.ChunkSize; i++)
                {
                    var value = (int) Math.Pow(2, i);
                    var mask = chunk.CableData[datum.CableType] & value;

                    if (mask == 0x0)
                        continue;

                    var relativeTile = SharedNavMapSystem.GetTile(mask);
                    var tile = (chunk.Origin * SharedNavMapSystem.ChunkSize + relativeTile) * grid.TileSize;
                    var position = new Vector2(tile.X, -tile.Y);
                    NavMapChunkPowerCables? neighborChunk;
                    bool neighbor;

                    // Only check the north and east neighbors

                    // East
                    if (relativeTile.X == SharedNavMapSystem.ChunkSize - 1)
                    {
                        neighbor = chunks.TryGetValue(chunkOrigin + new Vector2i(1, 0), out neighborChunk) &&
                                    (neighborChunk.CableData[datum.CableType] & SharedNavMapSystem.GetFlag(new Vector2i(0, relativeTile.Y))) != 0x0;
                    }
                    else
                    {
                        var flag = SharedNavMapSystem.GetFlag(relativeTile + new Vector2i(1, 0));
                        neighbor = (chunk.CableData[datum.CableType] & flag) != 0x0;
                    }

                    if (neighbor)
                    {
                        // Add points
                        var line = new ChunkedLine
                            (position + datum.Offset + new Vector2(grid.TileSize * 0.5f, -grid.TileSize * 0.5f),
                            position + new Vector2(1f, 0f) + datum.Offset + new Vector2(grid.TileSize * 0.5f, -grid.TileSize * 0.5f),
                            datum.Color);
                        list.Add(line);
                    }

                    // North
                    if (relativeTile.Y == SharedNavMapSystem.ChunkSize - 1)
                    {
                        neighbor = chunks.TryGetValue(chunkOrigin + new Vector2i(0, 1), out neighborChunk) &&
                                        (neighborChunk.CableData[datum.CableType] & SharedNavMapSystem.GetFlag(new Vector2i(relativeTile.X, 0))) != 0x0;
                    }
                    else
                    {
                        var flag = SharedNavMapSystem.GetFlag(relativeTile + new Vector2i(0, 1));
                        neighbor = (chunk.CableData[datum.CableType] & flag) != 0x0;
                    }

                    if (neighbor)
                    {
                        // Add points
                        var line = new ChunkedLine
                            (position + datum.Offset + new Vector2(grid.TileSize * 0.5f, -grid.TileSize * 0.5f),
                            position + new Vector2(0f, -1f) + datum.Offset + new Vector2(grid.TileSize * 0.5f, -grid.TileSize * 0.5f),
                            datum.Color);
                        list.Add(line);
                    }
                }

            }

            output.Add(chunkOrigin, list);
        }

        return output;
    }

    private Dictionary<Vector2i, List<ChunkedLine>> DecodeTileChunks(Dictionary<Vector2i, NavMapChunk> chunks, MapGridComponent grid)
    {
        var output = new Dictionary<Vector2i, List<ChunkedLine>>();

        foreach ((var chunkOrigin, var chunk) in chunks)
        {
            var list = new List<ChunkedLine>();

            // TODO: Okay maybe I should just use ushorts lmao...
            for (var i = 0; i < SharedNavMapSystem.ChunkSize * SharedNavMapSystem.ChunkSize; i++)
            {
                var value = (int) Math.Pow(2, i);

                var mask = chunk.TileData & value;

                if (mask == 0x0)
                    continue;

                // Alright now we'll work out our edges
                var relativeTile = SharedNavMapSystem.GetTile(mask);
                var tile = (chunk.Origin * SharedNavMapSystem.ChunkSize + relativeTile) * grid.TileSize;
                var position = new Vector2(tile.X, -tile.Y);
                NavMapChunk? neighborChunk;
                bool neighbor;

                // North edge
                if (relativeTile.Y == SharedNavMapSystem.ChunkSize - 1)
                {
                    neighbor = chunks.TryGetValue(chunkOrigin + new Vector2i(0, 1), out neighborChunk) &&
                                  (neighborChunk.TileData &
                                   SharedNavMapSystem.GetFlag(new Vector2i(relativeTile.X, 0))) != 0x0;
                }
                else
                {
                    var flag = SharedNavMapSystem.GetFlag(relativeTile + new Vector2i(0, 1));
                    neighbor = (chunk.TileData & flag) != 0x0;
                }

                if (!neighbor)
                {
                    // Add points
                    list.Add(new ChunkedLine(position + new Vector2(0f, -grid.TileSize), position + new Vector2(grid.TileSize, -grid.TileSize), Color.Cyan));
                }

                // East edge
                if (relativeTile.X == SharedNavMapSystem.ChunkSize - 1)
                {
                    neighbor = chunks.TryGetValue(chunkOrigin + new Vector2i(1, 0), out neighborChunk) &&
                               (neighborChunk.TileData &
                                SharedNavMapSystem.GetFlag(new Vector2i(0, relativeTile.Y))) != 0x0;
                }
                else
                {
                    var flag = SharedNavMapSystem.GetFlag(relativeTile + new Vector2i(1, 0));
                    neighbor = (chunk.TileData & flag) != 0x0;
                }

                if (!neighbor)
                {
                    // Add points
                    list.Add(new ChunkedLine(position + new Vector2(grid.TileSize, -grid.TileSize), position + new Vector2(grid.TileSize, 0f), Color.Cyan));
                }

                // South edge
                if (relativeTile.Y == 0)
                {
                    neighbor = chunks.TryGetValue(chunkOrigin + new Vector2i(0, -1), out neighborChunk) &&
                               (neighborChunk.TileData &
                                SharedNavMapSystem.GetFlag(new Vector2i(relativeTile.X, SharedNavMapSystem.ChunkSize - 1))) != 0x0;
                }
                else
                {
                    var flag = SharedNavMapSystem.GetFlag(relativeTile + new Vector2i(0, -1));
                    neighbor = (chunk.TileData & flag) != 0x0;
                }

                if (!neighbor)
                {
                    // Add points
                    list.Add(new ChunkedLine(position + new Vector2(grid.TileSize, 0f), position, Color.Cyan));
                }

                // West edge
                if (relativeTile.X == 0)
                {
                    neighbor = chunks.TryGetValue(chunkOrigin + new Vector2i(-1, 0), out neighborChunk) &&
                               (neighborChunk.TileData &
                                SharedNavMapSystem.GetFlag(new Vector2i(SharedNavMapSystem.ChunkSize - 1, relativeTile.Y))) != 0x0;
                }
                else
                {
                    var flag = SharedNavMapSystem.GetFlag(relativeTile + new Vector2i(-1, 0));
                    neighbor = (chunk.TileData & flag) != 0x0;
                }

                if (!neighbor)
                {
                    // Add point
                    list.Add(new ChunkedLine(position, position + new Vector2(0f, -grid.TileSize), Color.Cyan));
                }

                // Draw a diagonal line for interiors.
                list.Add(new ChunkedLine(position + new Vector2(0f, -grid.TileSize), position + new Vector2(grid.TileSize, 0f), Color.Cyan));
            }

            output.Add(chunkOrigin, list);
        }

        return output;
    }
}


public sealed class ChunkedLine
{
    public Vector2 Origin;
    public Vector2 Terminus;
    public Color Color;

    public ChunkedLine(Vector2 origin, Vector2 terminus, Color color)
    {
        Origin = origin;
        Terminus = terminus;
        Color = color;
    }
}

public sealed class PowerMonitoringEntry : BoxContainer
{
    public EntityUid EntityUid;
    public PowerMonitoringButton? Button;
    public GridContainer? MainGrid;
    public GridContainer? Sources;
    public GridContainer? Loads;
    public TextureRect? Symbol;
}


public sealed class PowerMonitoringButton : Button
{
    public int IndexInTable;
    public EntityUid? EntityUid;
    public EntityCoordinates? Coordinates;
    public GridContainer? Grid;
    public SpriteView? SpriteView;
    public Label? Name;
    public Label? Value;
}
