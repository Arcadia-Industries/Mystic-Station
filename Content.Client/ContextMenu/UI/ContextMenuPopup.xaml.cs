using Content.Client.Stylesheets;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Maths;
using Robust.Shared.Utility;
using static Robust.Client.UserInterface.Controls.BoxContainer;

namespace Content.Client.ContextMenu.UI
{
    /// <summary>
    ///     The base context-menu pop-up window used for both the entity and verb menus.
    /// </summary>
    [GenerateTypedNameReferences]
    public partial class ContextMenuPopup : Popup
    {
        public const string StyleClassContextMenuPopup = "contextMenuPopup";

        /// <summary>
        ///     How many items to list before limiting the size and adding a scroll bar.
        /// </summary>
        public const int MaxItemsBeforeScroll = 10;

        /// <summary>
        ///     If this pop-up is created by hovering over some element in another pop-up, this is that element.
        /// </summary>
        public ContextMenuElement? ParentElement;

        /// <summary>
        ///     This is the main body of the menu. The menu entries should be added to this object.
        /// </summary>
        public BoxContainer MenuBody = new() { Orientation = LayoutOrientation.Vertical };

        private ContextMenuPresenter _presenter;

        public ContextMenuPopup (ContextMenuPresenter presenter, ContextMenuElement? parentElement) : base()
        {
            RobustXamlLoader.Load(this);
            MenuPanel.SetOnlyStyleClass(StyleClassContextMenuPopup);

            _presenter = presenter;
            ParentElement = parentElement;

            //XAML controls are private. So defining and adding MenuBody here instead.
            Scroll.AddChild(MenuBody);

            // Set Max Height based on MaxItemsBeforeScroll and the panel's style box
            MenuPanel.TryGetStyleProperty<StyleBox>(PanelContainer.StylePropertyPanel, out var box);
            var styleSize = (box?.MinimumSize ?? Vector2.Zero) / UIScale;
            MaxHeight = MaxItemsBeforeScroll * (ContextMenuElement.ElementHeight + 2 * ContextMenuElement.ElementMargin) + styleSize.Y;

            UserInterfaceManager.ModalRoot.AddChild(this);
            MenuBody.OnChildRemoved += ctrl => _presenter.OnRemoveElement(this, ctrl);
            
            if (ParentElement != null)
            {
                DebugTools.Assert(ParentElement.SubMenu == null);
                ParentElement.SubMenu = this;
            }
        }

        protected override void Dispose(bool disposing)
        {
            MenuBody.OnChildRemoved -= ctrl => _presenter.OnRemoveElement(this, ctrl);
            ParentElement = null;
            base.Dispose(disposing);
        }

        protected override Vector2 MeasureOverride(Vector2 availableSize)
        {
            if (MenuBody.ChildCount == 0)
            {
                return Vector2.Zero;
            }

            // The crux of the issue here is that ScrollContainer does not return a desired size. This is a problem
            // given that we want to automatically resize the context menu, until it has a certain number of elements.
            //
            // So we have to manually infer the desired size, and then re-implement the PanelContainer.MeasureOverride
            // with it's style-box to get the actual desired size. This would be a lot easier if ScrollContainer gave it's size
            // directly to PanelContainer.
            //
            // Please someone just add an optional argument to ScrollContainer that makes it return its desired size.

            // Get the Panel container stylebox
            MenuPanel.TryGetStyleProperty<StyleBox>(PanelContainer.StylePropertyPanel, out var box);
            var styleSize = (box?.MinimumSize ?? Vector2.Zero) / UIScale;
            var measureSize = Vector2.ComponentMax(availableSize - styleSize, Vector2.Zero);

            Scroll.InvalidateMeasure();
            Scroll.Measure(measureSize);
            var desiredSize = MenuBody.DesiredSize;

            // account for scroll bar width
            if (desiredSize.Y + styleSize.Y > MaxHeight)
            {
                // Scroll._vScrollBar is private and ScrollContainer gives no size information :/
                // So we will just assume the scrollbar grabber style uses the default value.
                desiredSize.X += StyleBase.DefaultGrabberSize;
            }

            return desiredSize + styleSize;
        }
    }
}
