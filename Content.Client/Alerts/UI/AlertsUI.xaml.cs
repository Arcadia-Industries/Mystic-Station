using System;
using System.Collections.Generic;
using Content.Client.Chat.Managers;
using Content.Client.Chat.UI;
using Content.Shared.Alert;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.GameObjects;
using Robust.Shared.Input;
using Robust.Shared.IoC;
using Robust.Shared.Log;

namespace Content.Client.Alerts.UI;

public class AlertsFramePresenter : IDisposable
{
    [Dependency] private readonly IUserInterfaceManager _userInterfaceManager = default!;

    private IAlertsFrameView _alertsFrame;

    public AlertsFramePresenter()
    {
        // This is a lot easier than a factory
        IoCManager.InjectDependencies(this);

        _alertsFrame = new AlertsUI();
        _userInterfaceManager.StateRoot.AddChild((AlertsUI) _alertsFrame);

        //TODO: wire up view

        //TODO: wire up system
    }

    /// <inheritdoc />
    public void Dispose()
    {
        _userInterfaceManager.StateRoot.RemoveChild((AlertsUI) _alertsFrame);
        _alertsFrame.Dispose();
        _alertsFrame = null!;
    }

    private void SyncControls(AlertOrderPrototype? alertOrderPrototype, Dictionary<AlertKey, AlertState> alertStates)
    {
        _alertsFrame.SyncControls(alertOrderPrototype, alertStates);
    }

    protected void ClearControls()
    {
        _alertsFrame.ClearAllControls();
    }

    private static void HandleAlertPressed(AlertType alertPrototypeAlertType)
    {
        var alertsSystem = EntitySystem.Get<ClientAlertsSystem>();
        alertsSystem.AlertClicked(alertPrototypeAlertType);
    }
}

/// <summary>
///     This is the frame of vertical set of alerts that show up on the HUD.
/// </summary>
public interface IAlertsFrameView : IDisposable
{
    event EventHandler<AlertType>? AlertPressed;

    void SyncControls(AlertOrderPrototype? alertOrderPrototype, Dictionary<AlertKey, AlertState> alertStates);
    void ClearAllControls();
}

/// <summary>
///     The status effects display on the right side of the screen.
/// </summary>
[GenerateTypedNameReferences]
public sealed partial class AlertsUI : Control, IAlertsFrameView
{
    //TODO: WTF is this
    public const float ChatSeparation = 38f;

    private readonly Dictionary<AlertKey, AlertControl> _alertControls = new();
    [Dependency] private readonly IChatManager _chatManager = default!;

    public AlertsUI()
    {
        IoCManager.InjectDependencies(this);
        RobustXamlLoader.Load(this);

        LayoutContainer.SetGrowHorizontal(this, LayoutContainer.GrowDirection.Begin);
        LayoutContainer.SetGrowVertical(this, LayoutContainer.GrowDirection.End);
        LayoutContainer.SetAnchorTop(this, 0f);
        LayoutContainer.SetAnchorRight(this, 1f);
        LayoutContainer.SetAnchorBottom(this, 1f);
        LayoutContainer.SetMarginBottom(this, -180);
        LayoutContainer.SetMarginTop(this, 250);
        LayoutContainer.SetMarginRight(this, -10);
    }

    public void SyncControls(AlertOrderPrototype? alertOrderPrototype, Dictionary<AlertKey, AlertState> alertStates)
    {
        // remove any controls with keys no longer present
        if (SyncRemoveControls(alertStates)) return;

        // now we know that alertControls contains alerts that should still exist but
        // may need to updated,
        // also there may be some new alerts we need to show.
        // further, we need to ensure they are ordered w.r.t their configured order
        SyncUpdateControls(alertOrderPrototype, alertStates);
    }

    public void ClearAllControls()
    {
        foreach (var alertControl in _alertControls.Values)
        {
            alertControl.OnPressed -= AlertControlPressed;
        }

        //TODO: Properly dispose
        _alertControls.Clear();
    }

    public event EventHandler<AlertType>? AlertPressed;

    protected override void EnteredTree()
    {
        base.EnteredTree();
        _chatManager.OnChatBoxResized += OnChatResized;
        OnChatResized(new ChatResizedEventArgs(HudChatBox.InitialChatBottom));
    }

    protected override void ExitedTree()
    {
        base.ExitedTree();
        _chatManager.OnChatBoxResized -= OnChatResized;
    }

    // This makes no sense but I'm leaving it in place in case I break anything by removing it.
    protected override void Resized()
    {
        // TODO: Can rework this once https://github.com/space-wizards/RobustToolbox/issues/1392 is done,
        // this is here because there isn't currently a good way to allow the grid to adjust its height based
        // on constraints, otherwise we would use anchors to lay it out
        base.Resized();
        AlertContainer.MaxGridHeight = Height;
    }

    protected override void UIScaleChanged()
    {
        AlertContainer.MaxGridHeight = Height;
        base.UIScaleChanged();
    }

    private void OnChatResized(ChatResizedEventArgs chatResizedEventArgs)
    {
        // resize us to fit just below the chatbox
        if (_chatManager.CurrentChatBox != null)
            LayoutContainer.SetMarginTop(this, chatResizedEventArgs.NewBottom + ChatSeparation);
        else
            LayoutContainer.SetMarginTop(this, 250);
    }

    private bool SyncRemoveControls(Dictionary<AlertKey, AlertState> alertStates)
    {
        var toRemove = new List<AlertKey>();
        foreach (var existingKey in _alertControls.Keys)
        {
            if (!alertStates.ContainsKey(existingKey)) toRemove.Add(existingKey);
        }

        foreach (var alertKeyToRemove in toRemove)
        {
            _alertControls.Remove(alertKeyToRemove, out var control);
            if (control == null) return true;
            AlertContainer.Children.Remove(control);
        }

        return false;
    }

    private void SyncUpdateControls(AlertOrderPrototype? alertOrderPrototype, Dictionary<AlertKey, AlertState> alertStates)
    {
        foreach (var (alertKey, alertState) in alertStates)
        {
            if (!alertKey.AlertType.HasValue)
            {
                Logger.WarningS("alert", "found alertkey without alerttype," +
                                         " alert keys should never be stored without an alerttype set: {0}", alertKey);
                continue;
            }

            var alertType = alertKey.AlertType.Value;
            if (!SharedAlertsSystem.TryGet(alertType, out var newAlert))
            {
                Logger.ErrorS("alert", "Unrecognized alertType {0}", alertType);
                continue;
            }

            if (_alertControls.TryGetValue(newAlert.AlertKey, out var existingAlertControl) &&
                existingAlertControl.Alert.AlertType == newAlert.AlertType)
            {
                // key is the same, simply update the existing control severity / cooldown
                existingAlertControl.SetSeverity(alertState.Severity);
                existingAlertControl.Cooldown = alertState.Cooldown;
            }
            else
            {
                if (existingAlertControl != null) AlertContainer.Children.Remove(existingAlertControl);

                // this is a new alert + alert key or just a different alert with the same
                // key, create the control and add it in the appropriate order
                var newAlertControl = CreateAlertControl(newAlert, alertState);
                if (alertOrderPrototype != null)
                {
                    var added = false;
                    foreach (var alertControl in AlertContainer.Children)
                    {
                        if (alertOrderPrototype.Compare(newAlert, ((AlertControl) alertControl).Alert) >= 0)
                            continue;

                        var idx = alertControl.GetPositionInParent();
                        AlertContainer.Children.Add(newAlertControl);
                        newAlertControl.SetPositionInParent(idx);
                        added = true;
                        break;
                    }

                    if (!added) AlertContainer.Children.Add(newAlertControl);
                }
                else
                    AlertContainer.Children.Add(newAlertControl);

                _alertControls[newAlert.AlertKey] = newAlertControl;
            }
        }
    }

    private AlertControl CreateAlertControl(AlertPrototype alert, AlertState alertState)
    {
        var alertControl = new AlertControl(alert, alertState.Severity)
        {
            Cooldown = alertState.Cooldown
        };
        alertControl.OnPressed += AlertControlPressed;
        return alertControl;
    }

    private void AlertControlPressed(BaseButton.ButtonEventArgs args)
    {
        if (args.Button is not AlertControl control)
            return;

        if (args.Event.Function != EngineKeyFunctions.UIClick)
            return;

        AlertPressed?.Invoke(this, control.Alert.AlertType);
    }
}
