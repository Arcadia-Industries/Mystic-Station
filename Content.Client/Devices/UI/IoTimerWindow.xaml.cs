using System;
using Content.Shared.Devices;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.CustomControls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.IoC;
using Robust.Shared.Localization;
using Robust.Shared.Timing;

namespace Content.Client.Devices.UI
{
    [GenerateTypedNameReferences]
    public partial class IoTimerWindow : SS14Window
    {

        [Dependency]
        private readonly IGameTiming _gameTiming = default!;

        private bool _timerActive;
        public bool TimerActive
        {
            get => _timerActive;
            set
            {
                _timerActive = value;
                OnActiveSet();
            }
        }

        private int _duration;
        public int Duration
        {
            get => _duration;
            set
            {
                _duration = value;
                OnDurationSet();
            }

        }

        private bool _timerPaused;

        public bool TimerPaused
        {
            get => _timerPaused;
            set
            {
                _timerPaused = value;
                OnTimerPauseChanged();
            }
        }

        /// <summary>
        /// This is the fraction of 'progress' the timer has made since it was started.
        /// 0 being it was just started and 1 being it is finished.
        /// We update this whenever the timer is active and not paused.
        /// </summary>
        private float timerProgress = 0;

        public (TimeSpan, TimeSpan) StartAndEndTimes = (TimeSpan.Zero, TimeSpan.Zero);

        public event Action? OnStartTimerPressed;
        public event Action<int>? OnSetDurationPressed;
        public event Action? OnPauseTimerPressed;
        public event Action? OnResetTimerPressed;

        public IoTimerWindow()
        {
            RobustXamlLoader.Load(this);
            IoCManager.InjectDependencies(this);

            TimerDuration.IsValid =
                i => i is >= SharedIoTimerComponent.MinDuration and <= SharedIoTimerComponent.MaxDuration;

            TimerDuration.InitDefaultButtons();

            //normalize max and min slider value
            TimeLeftSlider.MaxValue = 1;
            TimeLeftSlider.MinValue = 0;

            TimerActive = false;

            StartTimerButton.OnPressed += args => OnStartTimerPressed?.Invoke();
            SetDurationButton.OnPressed += args => OnSetDurationPressed?.Invoke(TimerDuration.Value);
            PauseTimerButton.OnPressed += args => OnPauseTimerPressed?.Invoke();
            ResetTimerButton.OnPressed += args => OnResetTimerPressed?.Invoke();
        }

        protected override void FrameUpdate(FrameEventArgs args)
        {
            base.FrameUpdate(args);

            //only update when not paused.
            if (TimerActive && !TimerPaused)
            {
                var secondsPassed = (_gameTiming.CurTime - StartAndEndTimes.Item1).Seconds;
                timerProgress = 1 - secondsPassed / (float)Duration;
                TimeLeftSlider.Value = timerProgress;
                TimeLeft.Text = (Duration - secondsPassed).ToString();
            }
        }

        private void OnActiveSet()
        {
            if (TimerActive)
            {
                InActiveContainer.Visible = false;
                ActiveContainer.Visible = true;
            }
            else
            {
                InActiveContainer.Visible = true;
                ActiveContainer.Visible = false;
            }

        }

        private void OnDurationSet()
        {
            TimerDuration.OverrideValue(Duration);
        }

        private void OnTimerPauseChanged()
        {
            PauseTimerButton.Text = TimerPaused ? "Resume" : "Pause";
        }
    }
}
