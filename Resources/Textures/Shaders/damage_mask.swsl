// Has 2 circles, an inner one that is unaffected and an outer one. Anything past the outer one is full red
// and in-between is a gradient.

light_mode unshaded;

uniform highp float time;
// Uniforms because it makes testing way easier. If needed make it const.
uniform highp float outerCircleRadius;
uniform highp float outerCircleMaxRadius;
uniform highp float innerCircleRadius;
uniform highp float innerCircleMaxRadius;

const highp float pulseRate = 3.0;
const highp float darknessAlphaInner = 0.0;

// Gives a pulsing affect. The overlay also lerps from one level to another.
highp float getTime(highp float time) {
    return max(0.0, cos(2.0 * (time - 2.0) + sin((time / 2.0 - 0.5))));
}

void fragment() {
	highp vec2 pixelSize = vec2(1.0/SCREEN_PIXEL_SIZE.x, 1.0/SCREEN_PIXEL_SIZE.y);
	highp vec2 pixelCenter = pixelSize*0.5;
	highp float distance = length(FRAGCOORD.xy - pixelCenter);
	highp float time = getTime(time * pulseRate);
    
	highp float innerRadius = innerCircleRadius + time * (innerCircleMaxRadius - innerCircleRadius);
	highp float outerRadius = outerCircleRadius + time * (outerCircleMaxRadius - outerCircleRadius);
    
	if(distance > outerRadius) {
		COLOR = vec4(1.0, 0.0, 0.0, 1.0);
	}
	else if(distance < innerRadius) {
		COLOR = vec4(0.0, 0.0, 0.0, darknessAlphaInner);
	}
	else {
        	highp float intensity = (distance-innerRadius)/(outerRadius-innerRadius);
        	highp float ratio = (1.0-intensity)*darknessAlphaInner + intensity;
		COLOR = vec4(ratio, 0.0, 0.0, ratio);
	}
}
